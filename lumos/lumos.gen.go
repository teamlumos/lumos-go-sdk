// Package lumos provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package lumos

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	HTTPBearerScopes = "HTTPBearer.Scopes"
)

// Defines values for AccountLifecycleStatus.
const (
	AccountLifecycleStatusACCESSCREATED        AccountLifecycleStatus = "ACCESS_CREATED"
	AccountLifecycleStatusACCESSREMOVED        AccountLifecycleStatus = "ACCESS_REMOVED"
	AccountLifecycleStatusACTIVE               AccountLifecycleStatus = "ACTIVE"
	AccountLifecycleStatusARCHIVED             AccountLifecycleStatus = "ARCHIVED"
	AccountLifecycleStatusDEPROVISIONED        AccountLifecycleStatus = "DEPROVISIONED"
	AccountLifecycleStatusDISCOVERED           AccountLifecycleStatus = "DISCOVERED"
	AccountLifecycleStatusMANUALLYREMOVED      AccountLifecycleStatus = "MANUALLY_REMOVED"
	AccountLifecycleStatusNONCORPORATEACCOUNT  AccountLifecycleStatus = "NON_CORPORATE_ACCOUNT"
	AccountLifecycleStatusSTAGED               AccountLifecycleStatus = "STAGED"
	AccountLifecycleStatusSUSPENDED            AccountLifecycleStatus = "SUSPENDED"
	AccountLifecycleStatusWAITINGMANUALREMOVAL AccountLifecycleStatus = "WAITING_MANUAL_REMOVAL"
)

// Defines values for AccountType.
const (
	AccountTypeROLE    AccountType = "ROLE"
	AccountTypeSERVICE AccountType = "SERVICE"
	AccountTypeUSER    AccountType = "USER"
)

// Defines values for AllowedGroupsConfigType.
const (
	ALLGROUPS       AllowedGroupsConfigType = "ALL_GROUPS"
	SPECIFIEDGROUPS AllowedGroupsConfigType = "SPECIFIED_GROUPS"
)

// Defines values for AppStoreVisibilityOption.
const (
	HIDDEN  AppStoreVisibilityOption = "HIDDEN"
	VISIBLE AppStoreVisibilityOption = "VISIBLE"
)

// Defines values for ApproverType.
const (
	ApproverTypeGROUP ApproverType = "GROUP"
	ApproverTypeUSER  ApproverType = "USER"
)

// Defines values for DiscoverySource.
const (
	ATLASSIAN          DiscoverySource = "ATLASSIAN"
	GOOGLECLOUD        DiscoverySource = "GOOGLE_CLOUD"
	GSUITEDEEPINBOX    DiscoverySource = "GSUITE_DEEP_INBOX"
	GSUITEOAUTH        DiscoverySource = "GSUITE_OAUTH"
	GSUITEQUICKINBOX   DiscoverySource = "GSUITE_QUICK_INBOX"
	JUMPCLOUD          DiscoverySource = "JUMPCLOUD"
	LUMOSINTEGRATION   DiscoverySource = "LUMOS_INTEGRATION"
	MANUAL             DiscoverySource = "MANUAL"
	MICROSOFTDEEPINBOX DiscoverySource = "MICROSOFT_DEEP_INBOX"
	MICROSOFTGCC       DiscoverySource = "MICROSOFT_GCC"
	MICROSOFTOAUTH     DiscoverySource = "MICROSOFT_OAUTH"
	OKTA               DiscoverySource = "OKTA"
	ONELOGIN           DiscoverySource = "ONELOGIN"
)

// Defines values for FileUploadType.
const (
	Url FileUploadType = "url"
)

// Defines values for FlowState.
const (
	FAILURE    FlowState = "FAILURE"
	NOTSTARTED FlowState = "NOT_STARTED"
	RUNNING    FlowState = "RUNNING"
	SUCCESS    FlowState = "SUCCESS"
)

// Defines values for InlineWebhookType.
const (
	DEPROVISION       InlineWebhookType = "DEPROVISION"
	PREAPPROVAL       InlineWebhookType = "PRE_APPROVAL"
	PROVISION         InlineWebhookType = "PROVISION"
	REQUESTVALIDATION InlineWebhookType = "REQUEST_VALIDATION"
	SIEM              InlineWebhookType = "SIEM"
)

// Defines values for Lifecycle.
const (
	LifecycleNATIVE Lifecycle = "NATIVE"
	LifecycleSYNCED Lifecycle = "SYNCED"
)

// Defines values for ManagerApprovalOption.
const (
	INITIALAPPROVAL ManagerApprovalOption = "INITIAL_APPROVAL"
	NONE            ManagerApprovalOption = "NONE"
)

// Defines values for PermissionType.
const (
	PermissionTypeNATIVE PermissionType = "NATIVE"
	PermissionTypeSYNCED PermissionType = "SYNCED"
)

// Defines values for TimeBasedAccessOptions.
const (
	N12Hours  TimeBasedAccessOptions = "12 hours"
	N14Days   TimeBasedAccessOptions = "14 days"
	N2Hours   TimeBasedAccessOptions = "2 hours"
	N30Days   TimeBasedAccessOptions = "30 days"
	N4Hours   TimeBasedAccessOptions = "4 hours"
	N7Days    TimeBasedAccessOptions = "7 days"
	N90Days   TimeBasedAccessOptions = "90 days"
	Unlimited TimeBasedAccessOptions = "Unlimited"
)

// Defines values for UserLifecycleStatus.
const (
	UserLifecycleStatusACTIVE    UserLifecycleStatus = "ACTIVE"
	UserLifecycleStatusINACTIVE  UserLifecycleStatus = "INACTIVE"
	UserLifecycleStatusSTAGED    UserLifecycleStatus = "STAGED"
	UserLifecycleStatusSUSPENDED UserLifecycleStatus = "SUSPENDED"
)

// AccessRequest API version of DomainAppSupportRequest.
type AccessRequest struct {
	// AppId The ID of the app the request is for.
	AppId string `json:"app_id"`

	// AppName The name of the app the request is for.
	AppName   string     `json:"app_name"`
	ExpiresAt *time.Time `json:"expires_at,omitempty"`

	// Id The ID of the access request.
	Id string `json:"id"`

	// Notes The reason the user wrote for putting the access request into the given state.
	Notes                  *map[string]string             `json:"notes,omitempty"`
	RequestablePermissions *[]RequestablePermissionOutput `json:"requestable_permissions,omitempty"`
	RequestedAt            *time.Time                     `json:"requested_at,omitempty"`

	// RequesterUser The user who requested access. It's possible for one user to request access on another's behalf.
	RequesterUser User `json:"requester_user"`

	// Status The current status of the request.
	Status        SupportRequestStatus `json:"status"`
	SupporterUser *User                `json:"supporter_user,omitempty"`

	// TargetUser The user the request is for.
	TargetUser User `json:"target_user"`
}

// Account defines model for Account.
type Account struct {
	// AccountType The type of this account.
	AccountType AccountType `json:"account_type"`

	// AppId The ID of the app that owns this account.
	AppId string `json:"app_id"`

	// Email The email of this account.
	Email *string `json:"email,omitempty"`

	// UniqueIdentifier The stable identifier of this account.
	UniqueIdentifier string `json:"unique_identifier"`
}

// AccountInput defines model for AccountInput.
type AccountInput struct {
	// Email The email of this account.
	Email *string `json:"email,omitempty"`

	// FirstName The first name of the user.
	FirstName *string `json:"first_name,omitempty"`

	// LastActivity The datetime of last activity of the user.
	LastActivity *string `json:"last_activity,omitempty"`

	// LastLogin The datetime of last login of the user.
	LastLogin *string `json:"last_login,omitempty"`

	// LastName The last name of the user.
	LastName *string `json:"last_name,omitempty"`

	// Permissions The permissions of the account.
	Permissions *[]PermissionInput `json:"permissions,omitempty"`

	// Status The status of the account.
	Status *AccountLifecycleStatus `json:"status,omitempty"`

	// UniqueIdentifier The stable identifier of this account.
	UniqueIdentifier string `json:"unique_identifier"`
}

// AccountLifecycleStatus NOTE: If you update this, also update UserDomainAppLifecycleStatus
//
// DISCOVERED             - Account discovered through accountfinding. Could be noisy.
//
// STAGED                 - An account that has been queued for provisioning, but is not
//
//	provisioned yet. Relevant for Apps where provisioning is async
//	(eg. Okta, OneLogin).
//
// ACCESS_CREATED         - When an account has been provisioned but not accessed.
//
// ACTIVE                 - A live, active, accessible account.
//
// SUSPENDED              - The user can no longer access the account, the license may or may not
//
//	be removed. The account can be recovered.
//
// DEPROVISIONED          - The user can no longer access the account, the license was removed,
//
//	and the account cannot be recovered.
//
// ARCHIVED               - The user can no longer access the account, the license may or may not
//
//	be removed. The account can be recovered.
//
// MANUALLY_REMOVED       - The user can no longer access the account, the license is presumably
//
//	removed, but all of this was done manually
//
// ACCESS_REMOVED         - The user can no longer access the account, but a license may still
//
//	exist. This is the case when we remove access through Okta but not a
//	direct integration
//
// NON_CORPORATE_ACCOUNT  - The account doesn't exist, or is a personal employee account.
//
// WAITING_MANUAL_REMOVAL - Waiting manual removal, someone was requested to remove the user access
//
//	from the App, and we are waiting for an answer about it.
type AccountLifecycleStatus string

// AccountType An enumeration.
type AccountType string

// AccountsUploadInput defines model for AccountsUploadInput.
type AccountsUploadInput struct {
	// Accounts Accounts to upload.
	Accounts *[]AccountInput `json:"accounts,omitempty"`

	// AppId The ID of the app to upload accounts to.
	AppId string `json:"app_id"`
}

// ActivityLog API version of SIEMEvent
type ActivityLog struct {
	Actor                 map[string]interface{}   `json:"actor"`
	EventBeganAt          time.Time                `json:"event_began_at"`
	EventHash             string                   `json:"event_hash"`
	EventMetadata         map[string]interface{}   `json:"event_metadata"`
	EventType             string                   `json:"event_type"`
	EventTypeUserFriendly string                   `json:"event_type_user_friendly"`
	Outcome               string                   `json:"outcome"`
	Targets               []map[string]interface{} `json:"targets"`
}

// ActivityRecord defines model for ActivityRecord.
type ActivityRecord struct {
	// Account Metadata that Lumos can use to match the activity record to a software account within Lumos.
	Account ActivityRecordAccountInput `json:"account"`

	// App Metadata that Lumos can use to match the activity record to an application within Lumos.
	App *ActivityRecordAppInput `json:"app,omitempty"`

	// Event Metadata about the event being uploaded.
	Event ActivityRecordEventInput `json:"event"`

	// SourceAppId UUID of the application in Lumos where this activity record was sourced (e.g. the ID of Okta within Lumos)
	SourceAppId string `json:"source_app_id"`

	// Timestamp The timestamp of this event, in ISO 8601 format.
	Timestamp time.Time `json:"timestamp"`
}

// ActivityRecordAccountInput defines model for ActivityRecordAccountInput.
type ActivityRecordAccountInput struct {
	// Email The email associated with the account
	Email *string `json:"email,omitempty"`

	// ExternalId The external app's user ID for the account.
	ExternalId *string `json:"external_id,omitempty"`
}

// ActivityRecordAppInput defines model for ActivityRecordAppInput.
type ActivityRecordAppInput struct {
	// InstanceIdentifier The ID of the app.
	InstanceIdentifier string `json:"instance_identifier"`
}

// ActivityRecordEventInput defines model for ActivityRecordEventInput.
type ActivityRecordEventInput struct {
	// Type The type of event being uploaded.
	Type ActivityRecordEventType `json:"type"`
}

// ActivityRecordEventType An enumeration.
type ActivityRecordEventType = interface{}

// ActivityRecordInput defines model for ActivityRecordInput.
type ActivityRecordInput struct {
	// Records The activity records to upload.
	Records []ActivityRecord `json:"records"`
}

// ActivityRecordOutput defines model for ActivityRecordOutput.
type ActivityRecordOutput struct {
	// Job State of the job to post-process the records.
	Job SyncTaskOutput `json:"job"`
}

// AirbaseMilestoneEvent Model of the input we'll get from Airbase's webhook call.
// To be completed when we get docs.
type AirbaseMilestoneEvent = map[string]interface{}

// AllowedGroupsConfigInput defines model for AllowedGroupsConfigInput.
type AllowedGroupsConfigInput struct {
	// Groups The groups associated with this config.
	Groups *[]BaseGroup `json:"groups,omitempty"`

	// Type The type of this allowed groups config, can be all groups or specific.
	Type *AllowedGroupsConfigType `json:"type,omitempty"`
}

// AllowedGroupsConfigOutput defines model for AllowedGroupsConfigOutput.
type AllowedGroupsConfigOutput struct {
	// Groups The groups associated with this config.
	Groups *[]Group `json:"groups,omitempty"`

	// Type The type of this allowed groups config, can be all groups or specific.
	Type *AllowedGroupsConfigType `json:"type,omitempty"`
}

// AllowedGroupsConfigType An enumeration.
type AllowedGroupsConfigType string

// App defines model for App.
type App struct {
	// AllowMultiplePermissionSelection Whether the app is configured to allow multiple permissions to be requested at a time.
	AllowMultiplePermissionSelection bool `json:"allow_multiple_permission_selection"`

	// AppClassId The ID of the service associated with this app.
	AppClassId string `json:"app_class_id"`

	// Id The ID of this app.
	Id string `json:"id"`

	// InstanceId The ID of the instance associated with this app.
	InstanceId string `json:"instance_id"`

	// Sources The sources of this app.
	Sources []DiscoverySource `json:"sources"`

	// Status The status of this app.
	Status DomainAppStatus `json:"status"`

	// UserFriendlyLabel The user-friendly label of this app.
	UserFriendlyLabel string `json:"user_friendly_label"`
}

// AppAdminsInput defines model for AppAdminsInput.
type AppAdminsInput struct {
	// Groups Groups assigned as app admins.
	Groups *[]BaseGroup `json:"groups,omitempty"`

	// Users Users assigned as app admins.
	Users *[]BaseUser `json:"users,omitempty"`
}

// AppAdminsOutput defines model for AppAdminsOutput.
type AppAdminsOutput struct {
	// Groups Groups assigned as app admins.
	Groups *[]Group `json:"groups,omitempty"`

	// Users Users assigned as app admins.
	Users *[]User `json:"users,omitempty"`
}

// AppApproversInput defines model for AppApproversInput.
type AppApproversInput struct {
	// Groups Groups assigned as support request approvers.
	Groups *[]BaseGroup `json:"groups,omitempty"`

	// Users Users assigned as support request approvers.
	Users *[]BaseUser `json:"users,omitempty"`
}

// AppApproversOutput defines model for AppApproversOutput.
type AppApproversOutput struct {
	// Groups Groups assigned as support request approvers.
	Groups *[]Group `json:"groups,omitempty"`

	// Users Users assigned as support request approvers.
	Users *[]User `json:"users,omitempty"`
}

// AppInputCreate defines model for AppInputCreate.
type AppInputCreate struct {
	// Category The category of the app you're creating.
	Category *string `json:"category,omitempty"`

	// Description The description of the app you're creating.
	Description *string `json:"description,omitempty"`

	// Name The name of the app you're creating.
	Name *string `json:"name,omitempty"`
}

// AppStoreApp defines model for AppStoreApp.
type AppStoreApp struct {
	// AllowMultiplePermissionSelection Whether the app is configured to allow multiple permissions to be requested at a time.
	AllowMultiplePermissionSelection bool `json:"allow_multiple_permission_selection"`

	// AppClassId The ID of the service associated with this app.
	AppClassId string `json:"app_class_id"`

	// Id The ID of this app.
	Id string `json:"id"`

	// InstanceId The ID of the instance associated with this app.
	InstanceId string `json:"instance_id"`

	// Sources The sources of this app.
	Sources []DiscoverySource `json:"sources"`

	// Status The status of this app.
	Status DomainAppStatus `json:"status"`

	// UserFriendlyLabel The user-friendly label of this app.
	UserFriendlyLabel string `json:"user_friendly_label"`
}

// AppStoreAppSettingsInput defines model for AppStoreAppSettingsInput.
type AppStoreAppSettingsInput struct {
	// CustomRequestInstructions AppStore App instructions.
	CustomRequestInstructions *string `json:"custom_request_instructions,omitempty"`

	// Provisioning Provisioning flow configuration to request access to app.
	Provisioning *AppStoreAppSettingsProvisioningInput `json:"provisioning,omitempty"`

	// RequestFlow Request flow configuration to request access to app.
	RequestFlow *AppStoreAppSettingsRequestFlowInput `json:"request_flow,omitempty"`
}

// AppStoreAppSettingsOutput defines model for AppStoreAppSettingsOutput.
type AppStoreAppSettingsOutput struct {
	// CustomRequestInstructions AppStore App instructions.
	CustomRequestInstructions *string `json:"custom_request_instructions,omitempty"`

	// Provisioning Provisioning flow configuration to request access to app.
	Provisioning *AppStoreAppSettingsProvisioningOutput `json:"provisioning,omitempty"`

	// RequestFlow Request flow configuration to request access to app.
	RequestFlow *AppStoreAppSettingsRequestFlowOutput `json:"request_flow,omitempty"`
}

// AppStoreAppSettingsProvisioningInput defines model for AppStoreAppSettingsProvisioningInput.
type AppStoreAppSettingsProvisioningInput struct {
	// AccessRemovalInlineWebhook An inactivity workflow can be optionally associated with this app.
	AccessRemovalInlineWebhook *BaseInlineWebhook `json:"access_removal_inline_webhook,omitempty"`

	// CustomProvisioningInstructions Only Available if manual steps is active. During the provisioning step, send a custom message to app admins explaining how to provision a user to the app. Markdown for links and text formatting is supported.
	CustomProvisioningInstructions *string `json:"custom_provisioning_instructions,omitempty"`

	// GroupsProvisioning If enabled, Approvers must choose a group to provision the user to for access requests.
	GroupsProvisioning *GroupProvisioningOption `json:"groups_provisioning,omitempty"`

	// ManualStepsNeeded If enabled, Lumos will reach out to the App Admin after initial access is granted to perform additional manual steps. Note that if this option is enabled, this action must be confirmed by the App Admin in order to resolve the request.
	ManualStepsNeeded *bool `json:"manual_steps_needed,omitempty"`

	// ProvisioningWebhook The provisioning webhook optionally associated with this app.
	ProvisioningWebhook *BaseInlineWebhook `json:"provisioning_webhook,omitempty"`

	// TimeBasedAccess If enabled, users can request an app for a selected duration. After expiry, Lumos will automatically remove user's access.
	TimeBasedAccess *[]TimeBasedAccessOptions `json:"time_based_access,omitempty"`
}

// AppStoreAppSettingsProvisioningOutput defines model for AppStoreAppSettingsProvisioningOutput.
type AppStoreAppSettingsProvisioningOutput struct {
	// AccessRemovalInlineWebhook An inactivity workflow can be optionally associated with this config.
	AccessRemovalInlineWebhook *InlineWebhook `json:"access_removal_inline_webhook,omitempty"`

	// CustomProvisioningInstructions Only Available if manual steps is active. During the provisioning step, send a custom message to app admins explaining how to provision a user to the app. Markdown for links and text formatting is supported.
	CustomProvisioningInstructions *string `json:"custom_provisioning_instructions,omitempty"`

	// GroupsProvisioning If enabled, Approvers must choose a group to provision the user to for access requests.
	GroupsProvisioning *GroupProvisioningOption `json:"groups_provisioning,omitempty"`

	// ManualStepsNeeded If enabled, Lumos will reach out to the App Admin after initial access is granted to perform additional manual steps. Note that if this option is enabled, this action must be confirmed by the App Admin in order to resolve the request.
	ManualStepsNeeded *bool `json:"manual_steps_needed,omitempty"`

	// ProvisioningWebhook The provisioning webhook optionally associated with this config.
	ProvisioningWebhook *InlineWebhook `json:"provisioning_webhook,omitempty"`

	// TimeBasedAccess If enabled, users can request an app for a selected duration. After expiry, Lumos will automatically remove user's access.
	TimeBasedAccess *[]TimeBasedAccessOptions `json:"time_based_access,omitempty"`
}

// AppStoreAppSettingsRequestFlowInput defines model for AppStoreAppSettingsRequestFlowInput.
type AppStoreAppSettingsRequestFlowInput struct {
	// Admins AppStore App admins assigned.
	Admins *AppAdminsInput `json:"admins,omitempty"`

	// AllowedGroups The allowed groups associated with this config.
	AllowedGroups *AllowedGroupsConfigInput `json:"allowed_groups,omitempty"`

	// Approvers AppStore App approvers assigned.
	Approvers *AppApproversInput `json:"approvers,omitempty"`

	// ApproversStage2 AppStore App stage 2 approvers assigned.
	ApproversStage2 *AppApproversInput `json:"approvers_stage_2,omitempty"`

	// CustomApprovalMessage During the approval step, send a custom message to requesters. Markdown for links and text formatting is supported.
	CustomApprovalMessage *string `json:"custom_approval_message,omitempty"`

	// Discoverability AppStore App visibility.
	Discoverability *AppStoreVisibility `json:"discoverability,omitempty"`

	// RequestValidationInlineWebhook A request validation webhook can be optionally associated with this app.
	RequestValidationInlineWebhook *BaseInlineWebhook `json:"request_validation_inline_webhook,omitempty"`

	// RequireAdditionalApproval Only turn on when working with sensitive permissions to ensure a smooth employee experience.
	RequireAdditionalApproval *bool `json:"require_additional_approval,omitempty"`

	// RequireManagerApproval When a user makes an access request, require that their manager approves the request before moving on to additional approvals.
	RequireManagerApproval *bool `json:"require_manager_approval,omitempty"`
}

// AppStoreAppSettingsRequestFlowOutput defines model for AppStoreAppSettingsRequestFlowOutput.
type AppStoreAppSettingsRequestFlowOutput struct {
	// Admins AppStore App admins assigned.
	Admins *AppAdminsOutput `json:"admins,omitempty"`

	// AllowedGroups The allowed groups config associated with this config.
	AllowedGroups *AllowedGroupsConfigOutput `json:"allowed_groups,omitempty"`

	// Approvers AppStore App approvers assigned.
	Approvers *AppApproversOutput `json:"approvers,omitempty"`

	// ApproversStage2 AppStore App stage 2 approvers assigned.
	ApproversStage2 *AppApproversOutput `json:"approvers_stage_2,omitempty"`

	// CustomApprovalMessage During the approval step, send a custom message to requesters. Markdown for links and text formatting is supported.
	CustomApprovalMessage *string `json:"custom_approval_message,omitempty"`

	// Discoverability AppStore App visibility.
	Discoverability *AppStoreVisibility `json:"discoverability,omitempty"`

	// RequestValidationInlineWebhook A request validation webhook can be optionally associated with this config.
	RequestValidationInlineWebhook *InlineWebhook `json:"request_validation_inline_webhook,omitempty"`

	// RequireAdditionalApproval Only turn on when working with sensitive permissions to ensure a smooth employee experience.
	RequireAdditionalApproval *bool `json:"require_additional_approval,omitempty"`

	// RequireManagerApproval When a user makes an access request, require that their manager approves the request before moving on to additional approvals.
	RequireManagerApproval *bool `json:"require_manager_approval,omitempty"`
}

// AppStoreVisibility An enumeration.
type AppStoreVisibility = interface{}

// AppStoreVisibilityOption An enumeration.
type AppStoreVisibilityOption string

// ApproverInput defines model for ApproverInput.
type ApproverInput struct {
	// Group Optionally, the approver can be a group.
	Group *BaseGroup `json:"group,omitempty"`

	// Type The type of this approver.
	Type *ApproverType `json:"type,omitempty"`

	// User Optionally, the approver can be a user.
	User *BaseUser `json:"user,omitempty"`
}

// ApproverOutput defines model for ApproverOutput.
type ApproverOutput struct {
	// Group Optionally, the approver can be a group.
	Group *Group `json:"group,omitempty"`

	// Type The type of this approver.
	Type ApproverType `json:"type"`

	// User Optionally, the approver can be a user.
	User *User `json:"user,omitempty"`
}

// ApproverType An enumeration.
type ApproverType string

// BaseGroup defines model for BaseGroup.
type BaseGroup struct {
	// AppId The ID of the app that owns this group.
	AppId *string `json:"app_id,omitempty"`

	// Id The ID of this group.
	Id *string `json:"id,omitempty"`

	// IntegrationSpecificId The ID of this group, specific to the integration.
	IntegrationSpecificId *string `json:"integration_specific_id,omitempty"`
}

// BaseInlineWebhook defines model for BaseInlineWebhook.
type BaseInlineWebhook struct {
	// Id The ID of this inline webhook.
	Id string `json:"id"`
}

// BaseUser defines model for BaseUser.
type BaseUser struct {
	// Id The ID of this user.
	Id string `json:"id"`
}

// Cost defines model for Cost.
type Cost struct {
	// Currency The currency in which this cost is stored
	Currency *string `json:"currency,omitempty"`

	// Value The quantity of the cost in terms of the specified currency
	Value int `json:"value"`
}

// CreateAccessRequestInput defines model for CreateAccessRequestInput.
type CreateAccessRequestInput struct {
	AppId string `json:"app_id"`

	// ExpirationInSeconds Once granted, how long the access should last. Omit for permanent access.
	ExpirationInSeconds *int `json:"expiration_in_seconds,omitempty"`

	// Note Why the user needs access.
	Note string `json:"note"`

	// RequestablePermissionIds The IDs of the requestable permissions the user is requesting access to. Omit this to just request access to the app.
	RequestablePermissionIds *[]string `json:"requestable_permission_ids,omitempty"`

	// TargetUserId User to request access for. If omitted, request for the current user.
	TargetUserId *string `json:"target_user_id,omitempty"`
}

// DiscoverySource An enumeration.
type DiscoverySource string

// DomainAppStatus An enumeration.
type DomainAppStatus = interface{}

// FileUpload defines model for FileUpload.
type FileUpload struct {
	// Type The type of content being uploaded. The only supported type today is 'url'
	Type FileUploadType `json:"type"`

	// Value The data to upload. This should be a publicly accessible URL that resolves to a file
	Value string `json:"value"`
}

// FileUploadType An enumeration.
type FileUploadType string

// FlowState An enumeration.
type FlowState string

// FoundDocumentsUpload defines model for FoundDocumentsUpload.
type FoundDocumentsUpload struct {
	// EndDate The end of the vendor agreement
	EndDate *string `json:"end_date,omitempty"`

	// Files A list of URLs that resolve to files that should be attached to the Found Document
	Files []FileUpload `json:"files"`

	// LineItems The line items on the contract
	LineItems *[]LineItemUpload `json:"line_items,omitempty"`

	// SourceAppId By passing the ID of an application within Lumos, it will appear as if this Found Document was sourced from that app
	SourceAppId *string `json:"source_app_id,omitempty"`

	// StartDate The start of the vendor agreement
	StartDate *string `json:"start_date,omitempty"`

	// TotalCost The total cost of the contract. If this is a multi-year contract, this should include the cost for future years
	TotalCost *Cost `json:"total_cost,omitempty"`

	// UniqueIdentifier A value that can be used to uniquely identify this contract (e.g. PO number, file name, etc)
	UniqueIdentifier string `json:"unique_identifier"`

	// VendorName The name of the vendor that this document is for
	VendorName *string `json:"vendor_name,omitempty"`
}

// Group defines model for Group.
type Group struct {
	// AppId The ID of the app that owns this group.
	AppId *string `json:"app_id,omitempty"`

	// Description The description of this group.
	Description *string `json:"description,omitempty"`

	// Id The ID of this group.
	Id *string `json:"id,omitempty"`

	// IntegrationSpecificId The ID of this group, specific to the integration.
	IntegrationSpecificId *string `json:"integration_specific_id,omitempty"`

	// Lifecycle The lifecycle of this group.
	Lifecycle *Lifecycle `json:"lifecycle,omitempty"`

	// Name The name of this group.
	Name *string `json:"name,omitempty"`

	// SourceAppId The ID of the app that owns this group.
	SourceAppId *string `json:"source_app_id,omitempty"`
}

// GroupProvisioningOption An enumeration.
type GroupProvisioningOption = interface{}

// HTTPValidationError defines model for HTTPValidationError.
type HTTPValidationError struct {
	Detail *[]ValidationError `json:"detail,omitempty"`
}

// InlineWebhook defines model for InlineWebhook.
type InlineWebhook struct {
	// Description The description of this inline webhook.
	Description *string `json:"description,omitempty"`

	// HookType The type of this inline webhook.
	HookType InlineWebhookType `json:"hook_type"`

	// Id The ID of this inline webhook.
	Id string `json:"id"`

	// Name The name of this inline webhook.
	Name string `json:"name"`
}

// InlineWebhookType An enumeration.
type InlineWebhookType string

// JobStateOutput defines model for JobStateOutput.
type JobStateOutput struct {
	// JobId The ID of the job.
	JobId string `json:"job_id"`

	// State The state of the job.
	State *FlowState `json:"state,omitempty"`
}

// Lifecycle An enumeration.
type Lifecycle string

// LimitOffsetPageActivityLog defines model for LimitOffsetPage_ActivityLog_.
type LimitOffsetPageActivityLog struct {
	Items  []ActivityLog `json:"items"`
	Limit  *int          `json:"limit,omitempty"`
	Links  Links         `json:"links"`
	Offset *int          `json:"offset,omitempty"`
	Total  *int          `json:"total,omitempty"`
}

// LineItem defines model for LineItem.
type LineItem struct {
	// Name The name of the line item as stored in Lumos
	Name string `json:"name"`

	// Quantity The number of units purchased for this line item
	Quantity int `json:"quantity"`

	// Type The type of purchase that this line item refers to
	Type string `json:"type"`

	// UnitCost The unit cost of this line item
	UnitCost LineItemUnitCost `json:"unit_cost"`
}

// LineItemInput defines model for LineItemInput.
type LineItemInput struct {
	// Name The name of the line item as stored in Lumos
	Name string `json:"name"`

	// Quantity The number of units purchased for this line item
	Quantity int `json:"quantity"`

	// Type The type of purchase that this line item refers to
	Type string `json:"type"`

	// UnitCost The per-unit cost of the line item
	UnitCost LineItemUnitCostInput `json:"unit_cost"`
}

// LineItemUnitCost defines model for LineItemUnitCost.
type LineItemUnitCost struct {
	// PerMonth The per unit cost associated with this line item, amortized to the cost per month
	PerMonth Cost `json:"per_month"`
}

// LineItemUnitCostInput defines model for LineItemUnitCostInput.
type LineItemUnitCostInput struct {
	// Period The period which this cost covers. Available options are per_month or per_year
	Period string `json:"period"`

	// Value The cost in terms of the specified currency (4 decimal places supported)
	Value float32 `json:"value"`
}

// LineItemUpload defines model for LineItemUpload.
type LineItemUpload struct {
	// Name The name of the line item as stored in Lumos
	Name string `json:"name"`

	// Quantity The number of units purchased for this line item
	Quantity int `json:"quantity"`

	// UnitCost The unit cost of this line item
	UnitCost Cost `json:"unit_cost"`
}

// Links defines model for Links.
type Links struct {
	First *string `json:"first,omitempty"`
	Last  *string `json:"last,omitempty"`
	Next  *string `json:"next,omitempty"`
	Prev  *string `json:"prev,omitempty"`
	Self  *string `json:"self,omitempty"`
}

// ManagerApprovalOption An enumeration.
type ManagerApprovalOption string

// OrderCustomAttribute defines model for OrderCustomAttribute.
type OrderCustomAttribute struct {
	// Type The type of custom attribute. Only text and user options are available today
	Type OrderCustomAttributeType `json:"type"`

	// Value The value of the attribute for an individual Order
	Value *string `json:"value,omitempty"`
}

// OrderCustomAttributeType An enumeration.
type OrderCustomAttributeType = interface{}

// OrderInput defines model for OrderInput.
type OrderInput struct {
	// AutoRenewal Whether or not the contract auto-renews
	AutoRenewal bool `json:"auto_renewal"`

	// Currency The currency in which the contract is being paid in ISO 4217 format
	Currency *string `json:"currency,omitempty"`

	// CustomAttributes Any additional attributes that you would like to save on the Order. The set of available options must be configured in advance in Lumos.
	CustomAttributes *map[string]OrderCustomAttribute `json:"custom_attributes,omitempty"`

	// EndDate The end date of the attached contract
	EndDate openapi_types.Date `json:"end_date"`

	// LineItems The list of currently active line items for this Vendor Agreement. If there are no currently active line items, the most recent set of line items is returned.
	LineItems []LineItemInput `json:"line_items"`

	// OptOutDate The date by which a vendor must be notified before terminating the order
	OptOutDate *openapi_types.Date `json:"opt_out_date,omitempty"`

	// SourceAppId UUID of the application in Lumos where this order was sourced (e.g. the ID of Ironclad within Lumos)
	SourceAppId *string `json:"source_app_id,omitempty"`

	// StartDate The start date of the attached contract
	StartDate openapi_types.Date `json:"start_date"`

	// UniqueIdentifier A unique ID for the contract being uploaded. This can be an ID from an external system like Ironclad, an internal ID such as a PO number, or simply the name of the vendor + date of the contract.
	UniqueIdentifier string `json:"unique_identifier"`

	// Vendor Information about the vendor associated with this contract. Currently, we will only support a name field.
	Vendor Vendor `json:"vendor"`
}

// PageAccessRequest defines model for Page_AccessRequest_.
type PageAccessRequest struct {
	Items []AccessRequest `json:"items"`
	Page  *int            `json:"page,omitempty"`
	Pages *int            `json:"pages,omitempty"`
	Size  *int            `json:"size,omitempty"`
	Total *int            `json:"total,omitempty"`
}

// PageAccount defines model for Page_Account_.
type PageAccount struct {
	Items []Account `json:"items"`
	Page  *int      `json:"page,omitempty"`
	Pages *int      `json:"pages,omitempty"`
	Size  *int      `json:"size,omitempty"`
	Total *int      `json:"total,omitempty"`
}

// PageAppStoreApp defines model for Page_AppStoreApp_.
type PageAppStoreApp struct {
	Items []AppStoreApp `json:"items"`
	Page  *int          `json:"page,omitempty"`
	Pages *int          `json:"pages,omitempty"`
	Size  *int          `json:"size,omitempty"`
	Total *int          `json:"total,omitempty"`
}

// PageApp defines model for Page_App_.
type PageApp struct {
	Items []App `json:"items"`
	Page  *int  `json:"page,omitempty"`
	Pages *int  `json:"pages,omitempty"`
	Size  *int  `json:"size,omitempty"`
	Total *int  `json:"total,omitempty"`
}

// PageGroup defines model for Page_Group_.
type PageGroup struct {
	Items []Group `json:"items"`
	Page  *int    `json:"page,omitempty"`
	Pages *int    `json:"pages,omitempty"`
	Size  *int    `json:"size,omitempty"`
	Total *int    `json:"total,omitempty"`
}

// PagePreApprovalRuleOutput defines model for Page_PreApprovalRuleOutput_.
type PagePreApprovalRuleOutput struct {
	Items []PreApprovalRuleOutput `json:"items"`
	Page  *int                    `json:"page,omitempty"`
	Pages *int                    `json:"pages,omitempty"`
	Size  *int                    `json:"size,omitempty"`
	Total *int                    `json:"total,omitempty"`
}

// PageRequestablePermissionOutput defines model for Page_RequestablePermissionOutput_.
type PageRequestablePermissionOutput struct {
	Items []RequestablePermissionOutput `json:"items"`
	Page  *int                          `json:"page,omitempty"`
	Pages *int                          `json:"pages,omitempty"`
	Size  *int                          `json:"size,omitempty"`
	Total *int                          `json:"total,omitempty"`
}

// PageUser defines model for Page_User_.
type PageUser struct {
	Items []User `json:"items"`
	Page  *int   `json:"page,omitempty"`
	Pages *int   `json:"pages,omitempty"`
	Size  *int   `json:"size,omitempty"`
	Total *int   `json:"total,omitempty"`
}

// PageVendorAgreement defines model for Page_VendorAgreement_.
type PageVendorAgreement struct {
	Items []VendorAgreement `json:"items"`
	Page  *int              `json:"page,omitempty"`
	Pages *int              `json:"pages,omitempty"`
	Size  *int              `json:"size,omitempty"`
	Total *int              `json:"total,omitempty"`
}

// PermissionInput defines model for PermissionInput.
type PermissionInput struct {
	// Name The name of the permission.
	Name *string `json:"name,omitempty"`

	// Type The type of the permission.
	Type *string `json:"type,omitempty"`

	// UniqueIdentifier The unique identifier of the permission.
	UniqueIdentifier *string `json:"unique_identifier,omitempty"`
}

// PermissionType An enumeration.
type PermissionType string

// PreApprovalRuleInput defines model for PreApprovalRuleInput.
type PreApprovalRuleInput struct {
	// AppClassId The ID of the service associated with this pre-approval rule.
	AppClassId *string `json:"app_class_id,omitempty"`

	// AppId The ID of the app associated with this pre-approval rule.
	AppId *string `json:"app_id,omitempty"`

	// AppInstanceId Optionally, an app has an identifer associated with it's particular instance.
	AppInstanceId *string `json:"app_instance_id,omitempty"`

	// Id The ID of this preapproval rule.
	Id *string `json:"id,omitempty"`

	// Justification The justification of this preapproval rule.
	Justification *string `json:"justification,omitempty"`

	// PreapprovalWebhooks The preapproval webhooks of this preapproval rule.
	PreapprovalWebhooks *[]BaseInlineWebhook `json:"preapproval_webhooks,omitempty"`

	// PreapprovedGroups The preapproved groups of this preapproval rule.
	PreapprovedGroups *[]BaseGroup `json:"preapproved_groups,omitempty"`

	// PreapprovedPermissions The preapproved permissions of this preapproval rule.
	PreapprovedPermissions *[]RequestablePermissionBase `json:"preapproved_permissions,omitempty"`

	// TimeBasedAccess Users will be pre-approved only when they request for the time lengths selected here. When multiple permissions are selected, only time lengths that are valid for all of the selected permissions will show.
	TimeBasedAccess *[]TimeBasedAccessOptions `json:"time_based_access,omitempty"`
}

// PreApprovalRuleOutput defines model for PreApprovalRuleOutput.
type PreApprovalRuleOutput struct {
	// AppClassId The ID of the service associated with this pre-approval rule.
	AppClassId *string `json:"app_class_id,omitempty"`

	// AppId The ID of the app associated with this pre-approval rule.
	AppId *string `json:"app_id,omitempty"`

	// AppInstanceId Optionally, an app has an identifer associated with it's particular instance.
	AppInstanceId *string `json:"app_instance_id,omitempty"`

	// Id The ID of this preapproval rule.
	Id *string `json:"id,omitempty"`

	// Justification The justification of this preapproval rule.
	Justification string `json:"justification"`

	// PreapprovalWebhooks The preapproval webhooks of this preapproval rule.
	PreapprovalWebhooks *[]InlineWebhook `json:"preapproval_webhooks,omitempty"`

	// PreapprovedGroups The preapproved groups of this preapproval rule.
	PreapprovedGroups *[]Group `json:"preapproved_groups,omitempty"`

	// PreapprovedPermissions The preapproved permissions of this preapproval rule.
	PreapprovedPermissions *[]RequestablePermissionBaseOutput `json:"preapproved_permissions,omitempty"`

	// TimeBasedAccess Preapproval rule time access length,
	TimeBasedAccess *[]TimeBasedAccessOptions `json:"time_based_access,omitempty"`
}

// PreApprovalRuleUpdateInput defines model for PreApprovalRuleUpdateInput.
type PreApprovalRuleUpdateInput struct {
	// Id The ID of this preapproval rule.
	Id *string `json:"id,omitempty"`

	// Justification The justification of this preapproval rule.
	Justification *string `json:"justification,omitempty"`

	// PreapprovalWebhooks The preapproval webhooks of this preapproval rule.
	PreapprovalWebhooks *[]BaseInlineWebhook `json:"preapproval_webhooks,omitempty"`

	// PreapprovedGroups The preapproved groups of this preapproval rule.
	PreapprovedGroups *[]BaseGroup `json:"preapproved_groups,omitempty"`

	// PreapprovedPermissions The preapproved permissions of this preapproval rule.
	PreapprovedPermissions *[]RequestablePermissionBase `json:"preapproved_permissions,omitempty"`

	// TimeBasedAccess Users will be pre-approved only when they request for the time lengths selected here. When multiple permissions are selected, only time lengths that are valid for all of the selected permissions will show.
	TimeBasedAccess *[]TimeBasedAccessOptions `json:"time_based_access,omitempty"`
}

// RequestApprovalConfigInput defines model for RequestApprovalConfigInput.
type RequestApprovalConfigInput struct {
	// CustomApprovalMessage During the approval step, send a custom message to requesters. Note that the Permission level approval message will override the App level approval message. Markdown for links and text formatting is supported.
	CustomApprovalMessage *string `json:"custom_approval_message,omitempty"`

	// CustomApprovalMessageOverride Indicates if custom_approval_message is overrided
	CustomApprovalMessageOverride *bool `json:"custom_approval_message_override,omitempty"`

	// ManagerApproval Manager approval can be configured as necessary to continue
	ManagerApproval *ManagerApprovalOption `json:"manager_approval,omitempty"`

	// RequestApprovalConfigOverride Indicates if approval flow is overrided
	RequestApprovalConfigOverride *bool `json:"request_approval_config_override,omitempty"`

	// RequestApprovalStages The stages of this request approval.
	RequestApprovalStages *[]RequestApprovalStageInput `json:"request_approval_stages,omitempty"`

	// RequireAdditionalApproval Only turn on when working with sensitive permissions to ensure a smooth employee experience.
	RequireAdditionalApproval *bool `json:"require_additional_approval,omitempty"`
}

// RequestApprovalConfigOutput defines model for RequestApprovalConfigOutput.
type RequestApprovalConfigOutput struct {
	// CustomApprovalMessage During the approval step, send a custom message to requesters. Note that the Permission level approval message will override the App level approval message. Markdown for links and text formatting is supported.
	CustomApprovalMessage *string `json:"custom_approval_message,omitempty"`

	// CustomApprovalMessageOverride Indicates if custom_approval_message is overrided
	CustomApprovalMessageOverride *bool `json:"custom_approval_message_override,omitempty"`

	// ManagerApproval Manager approval can be configured as necessary to continue
	ManagerApproval *ManagerApprovalOption `json:"manager_approval,omitempty"`

	// RequestApprovalConfigOverride Indicates if approval flow is overrided
	RequestApprovalConfigOverride *bool `json:"request_approval_config_override,omitempty"`

	// RequestApprovalStages The stages of this request approval.
	RequestApprovalStages *[]RequestApprovalStageOutput `json:"request_approval_stages,omitempty"`

	// RequireAdditionalApproval Only turn on when working with sensitive permissions to ensure a smooth employee experience.
	RequireAdditionalApproval *bool `json:"require_additional_approval,omitempty"`
}

// RequestApprovalStageInput defines model for RequestApprovalStageInput.
type RequestApprovalStageInput struct {
	// Approvers The approvers of this stage.
	Approvers *[]ApproverInput `json:"approvers,omitempty"`
}

// RequestApprovalStageOutput defines model for RequestApprovalStageOutput.
type RequestApprovalStageOutput struct {
	// Approvers The approvers of this stage.
	Approvers *[]ApproverOutput `json:"approvers,omitempty"`
}

// RequestConfigInputCreate defines model for RequestConfigInputCreate.
type RequestConfigInputCreate struct {
	// AccessRemovalInlineWebhook An inactivity workflow can be optionally associated with this config.
	AccessRemovalInlineWebhook *BaseInlineWebhook `json:"access_removal_inline_webhook,omitempty"`

	// AllowedGroups The allowed groups associated with this config.
	AllowedGroups *AllowedGroupsConfigInput `json:"allowed_groups,omitempty"`

	// AllowedGroupsOverride Indicates if allowed groups is overrided
	AllowedGroupsOverride *bool `json:"allowed_groups_override,omitempty"`

	// AppstoreVisibility The appstore visibility of this request config.
	AppstoreVisibility *AppStoreVisibilityOption `json:"appstore_visibility,omitempty"`

	// RequestApprovalConfig A request approval config can be optionally associated with this config
	RequestApprovalConfig *RequestApprovalConfigInput `json:"request_approval_config,omitempty"`

	// RequestFulfillmentConfig A request fulfillment config can be optionally associated with this config
	RequestFulfillmentConfig *RequestFulfillmentConfigInput `json:"request_fulfillment_config,omitempty"`

	// RequestValidationInlineWebhook A request validation webhook can be optionally associated with this config.
	RequestValidationInlineWebhook *BaseInlineWebhook `json:"request_validation_inline_webhook,omitempty"`
}

// RequestConfigInputUpdate defines model for RequestConfigInputUpdate.
type RequestConfigInputUpdate struct {
	// AccessRemovalInlineWebhook An inactivity workflow can be optionally associated with this config.
	AccessRemovalInlineWebhook *BaseInlineWebhook `json:"access_removal_inline_webhook,omitempty"`

	// AllowedGroups The allowed groups associated with this config.
	AllowedGroups *AllowedGroupsConfigInput `json:"allowed_groups,omitempty"`

	// AllowedGroupsOverride Indicates if allowed groups is overrided
	AllowedGroupsOverride *bool `json:"allowed_groups_override,omitempty"`

	// AppstoreVisibility The appstore visibility of this request config.
	AppstoreVisibility *AppStoreVisibilityOption `json:"appstore_visibility,omitempty"`

	// RequestApprovalConfig A request approval config can be optionally associated with this config
	RequestApprovalConfig *RequestApprovalConfigInput `json:"request_approval_config,omitempty"`

	// RequestFulfillmentConfig A request fulfillment config can be optionally associated with this config
	RequestFulfillmentConfig *RequestFulfillmentConfigInputUpdate `json:"request_fulfillment_config,omitempty"`

	// RequestValidationInlineWebhook A request validation webhook can be optionally associated with this config.
	RequestValidationInlineWebhook *BaseInlineWebhook `json:"request_validation_inline_webhook,omitempty"`
}

// RequestConfigOutput defines model for RequestConfigOutput.
type RequestConfigOutput struct {
	// AccessRemovalInlineWebhook An inactivity workflow can be optionally associated with this config.
	AccessRemovalInlineWebhook *InlineWebhook `json:"access_removal_inline_webhook,omitempty"`

	// AllowedGroups The allowed groups config associated with this config.
	AllowedGroups *AllowedGroupsConfigOutput `json:"allowed_groups,omitempty"`

	// AllowedGroupsOverride Indicates if allowed groups is overrided
	AllowedGroupsOverride *bool `json:"allowed_groups_override,omitempty"`

	// AppstoreVisibility The appstore visibility of this request config.
	AppstoreVisibility *AppStoreVisibilityOption `json:"appstore_visibility,omitempty"`

	// RequestApprovalConfig A request approval config can be optionally associated with this config
	RequestApprovalConfig *RequestApprovalConfigOutput `json:"request_approval_config,omitempty"`

	// RequestFulfillmentConfig A request fulfillment config can be optionally associated with this config
	RequestFulfillmentConfig *RequestFulfillmentConfigOutput `json:"request_fulfillment_config,omitempty"`

	// RequestValidationInlineWebhook A request validation webhook can be optionally associated with this config.
	RequestValidationInlineWebhook *InlineWebhook `json:"request_validation_inline_webhook,omitempty"`
}

// RequestFulfillmentConfigInput defines model for RequestFulfillmentConfigInput.
type RequestFulfillmentConfigInput struct {
	// ManualInstructions The manual instructions that go along.
	ManualInstructions *string `json:"manual_instructions,omitempty"`

	// ManualStepsNeeded Whether manual steps are needed.
	ManualStepsNeeded *bool `json:"manual_steps_needed,omitempty"`

	// ProvisioningGroup The provisioning group optionally associated with this config.
	ProvisioningGroup *BaseGroup `json:"provisioning_group,omitempty"`

	// ProvisioningWebhook The provisioning webhook optionally associated with this config.
	ProvisioningWebhook *BaseInlineWebhook `json:"provisioning_webhook,omitempty"`

	// TimeBasedAccess If enabled, users can request an app for a selected duration. After expiry, Lumos will automatically remove user's access.
	TimeBasedAccess *[]TimeBasedAccessOptions `json:"time_based_access,omitempty"`

	// TimeBasedAccessOverride Indicates if time based access is overrided
	TimeBasedAccessOverride *bool `json:"time_based_access_override,omitempty"`
}

// RequestFulfillmentConfigInputUpdate defines model for RequestFulfillmentConfigInputUpdate.
type RequestFulfillmentConfigInputUpdate struct {
	// ManualInstructions The manual instructions that go along.
	ManualInstructions *string `json:"manual_instructions,omitempty"`

	// ManualStepsNeeded Whether manual steps are needed.
	ManualStepsNeeded *bool `json:"manual_steps_needed,omitempty"`

	// ProvisioningWebhook The provisioning webhook optionally associated with this config.
	ProvisioningWebhook *BaseInlineWebhook `json:"provisioning_webhook,omitempty"`

	// TimeBasedAccess If enabled, users can request an app for a selected duration. After expiry, Lumos will automatically remove user's access.
	TimeBasedAccess *[]TimeBasedAccessOptions `json:"time_based_access,omitempty"`

	// TimeBasedAccessOverride Indicates if time based access is overrided
	TimeBasedAccessOverride *bool `json:"time_based_access_override,omitempty"`
}

// RequestFulfillmentConfigOutput defines model for RequestFulfillmentConfigOutput.
type RequestFulfillmentConfigOutput struct {
	// ManualInstructions The manual instructions that go along.
	ManualInstructions *string `json:"manual_instructions,omitempty"`

	// ManualStepsNeeded Whether manual steps are needed.
	ManualStepsNeeded *bool `json:"manual_steps_needed,omitempty"`

	// ProvisioningGroup The provisioning group optionally assocated with this config.
	ProvisioningGroup *Group `json:"provisioning_group,omitempty"`

	// ProvisioningWebhook The provisioning webhook optionally associated with this config.
	ProvisioningWebhook *InlineWebhook `json:"provisioning_webhook,omitempty"`

	// TimeBasedAccess If enabled, users can request an app for a selected duration. After expiry, Lumos will automatically remove user's access.
	TimeBasedAccess *[]TimeBasedAccessOptions `json:"time_based_access,omitempty"`

	// TimeBasedAccessOverride Indicates if time based access is overrided
	TimeBasedAccessOverride *bool `json:"time_based_access_override,omitempty"`
}

// RequestablePermissionBase defines model for RequestablePermissionBase.
type RequestablePermissionBase struct {
	// Id The ID of this requestable permission.
	Id *string `json:"id,omitempty"`
}

// RequestablePermissionBaseOutput defines model for RequestablePermissionBaseOutput.
type RequestablePermissionBaseOutput struct {
	// AppClassId The ID of the service associated with this requestable permission.
	AppClassId string `json:"app_class_id"`

	// AppId The ID of the app associated with this requestable permission.
	AppId string `json:"app_id"`

	// AppInstanceId The ID of the instance associated with this requestable permission.
	AppInstanceId string `json:"app_instance_id"`

	// Id The ID of this requestable permission.
	Id *string `json:"id,omitempty"`

	// Label The label of this requestable permission.
	Label string `json:"label"`

	// Type The type of this requestable permission.
	Type *PermissionType `json:"type,omitempty"`
}

// RequestablePermissionInput defines model for RequestablePermissionInput.
type RequestablePermissionInput struct {
	// AppClassId The ID of the service associated with this requestable permission.
	AppClassId *string `json:"app_class_id,omitempty"`

	// AppId The ID of the app associated with this requestable permission.
	AppId *string `json:"app_id,omitempty"`

	// AppInstanceId Optionally, an app has an identifer associated with it's particular instance.
	AppInstanceId *string `json:"app_instance_id,omitempty"`

	// Label The label of this requestable permission.
	Label string `json:"label"`

	// RequestConfig The request config associated with this requestable permission.
	RequestConfig *RequestConfigInputCreate `json:"request_config,omitempty"`
}

// RequestablePermissionInputUpdate defines model for RequestablePermissionInputUpdate.
type RequestablePermissionInputUpdate struct {
	// AppClassId The ID of the service associated with this requestable permission.
	AppClassId *string `json:"app_class_id,omitempty"`

	// AppId The ID of the app associated with this requestable permission.
	AppId *string `json:"app_id,omitempty"`

	// AppInstanceId Optionally, an app has an identifer associated with it's particular instance.
	AppInstanceId *string `json:"app_instance_id,omitempty"`

	// Label The label of this requestable permission.
	Label *string `json:"label,omitempty"`

	// RequestConfig The request config associated with this requestable permission.
	RequestConfig *RequestConfigInputUpdate `json:"request_config,omitempty"`
}

// RequestablePermissionOutput defines model for RequestablePermissionOutput.
type RequestablePermissionOutput struct {
	// AppClassId The ID of the service associated with this requestable permission.
	AppClassId string `json:"app_class_id"`

	// AppId The ID of the app associated with this requestable permission.
	AppId string `json:"app_id"`

	// AppInstanceId The ID of the instance associated with this requestable permission.
	AppInstanceId string `json:"app_instance_id"`

	// Id The ID of this requestable permission.
	Id *string `json:"id,omitempty"`

	// Label The label of this requestable permission.
	Label string `json:"label"`

	// RequestConfig The request config associated with this requestable permission.
	RequestConfig RequestConfigOutput `json:"request_config"`

	// Type The type of this requestable permission.
	Type *PermissionType `json:"type,omitempty"`
}

// RunInfoStatus An enumeration.
type RunInfoStatus = interface{}

// SupportRequestStatus An enumeration.
type SupportRequestStatus = interface{}

// SyncTaskOutput defines model for SyncTaskOutput.
type SyncTaskOutput struct {
	// JobId The ID of the job.
	JobId string `json:"job_id"`

	// State The state of the job.
	State *RunInfoStatus `json:"state,omitempty"`
}

// TimeBasedAccessOptions An enumeration.
type TimeBasedAccessOptions string

// User defines model for User.
type User struct {
	// Email The email of this user.
	Email *string `json:"email,omitempty"`

	// FamilyName The family name of this user.
	FamilyName *string `json:"family_name,omitempty"`

	// GivenName The given name of this user.
	GivenName *string `json:"given_name,omitempty"`

	// Id The ID of this user.
	Id string `json:"id"`

	// Status The status of this user.
	Status *UserLifecycleStatus `json:"status,omitempty"`
}

// UserLifecycleStatus An enumeration.
type UserLifecycleStatus string

// ValidationError defines model for ValidationError.
type ValidationError struct {
	Loc  []ValidationError_Loc_Item `json:"loc"`
	Msg  string                     `json:"msg"`
	Type string                     `json:"type"`
}

// ValidationErrorLoc0 defines model for .
type ValidationErrorLoc0 = string

// ValidationErrorLoc1 defines model for .
type ValidationErrorLoc1 = int

// ValidationError_Loc_Item defines model for ValidationError.loc.Item.
type ValidationError_Loc_Item struct {
	union json.RawMessage
}

// Vendor defines model for Vendor.
type Vendor struct {
	// Name A user friendly name for the vendor
	Name string `json:"name"`
}

// VendorAgreement defines model for VendorAgreement.
type VendorAgreement struct {
	// EndDate The end of the current term
	EndDate openapi_types.Date `json:"end_date"`

	// Id A unique identifier for this Vendor Agreement
	Id string `json:"id"`

	// LineItems The list of currently active line items for this Vendor Agreement. If there are no currently active line items, the most recent set of line items is returned.
	LineItems []LineItem `json:"line_items"`

	// OptOutDate The date by which the vendor must be notified if you want to terminate the agreement
	OptOutDate openapi_types.Date `json:"opt_out_date"`

	// StartDate The start of the current term
	StartDate openapi_types.Date `json:"start_date"`

	// TotalContractCost The total cost of the current service term, including all line items and true ups, and including future years for multi-year agreements.
	TotalContractCost Cost `json:"total_contract_cost"`

	// Vendor The vendor in which the agreement is created for
	Vendor Vendor `json:"vendor"`
}

// GetAccountsParams defines parameters for GetAccounts.
type GetAccountsParams struct {
	AppId *string `form:"app_id,omitempty" json:"app_id,omitempty"`
	Page  *int    `form:"page,omitempty" json:"page,omitempty"`
	Size  *int    `form:"size,omitempty" json:"size,omitempty"`
}

// GetActivityLogsParams defines parameters for GetActivityLogs.
type GetActivityLogsParams struct {
	Since  *string `form:"since,omitempty" json:"since,omitempty"`
	Until  *string `form:"until,omitempty" json:"until,omitempty"`
	Limit  *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int    `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListAppsParams defines parameters for ListApps.
type ListAppsParams struct {
	Page *int `form:"page,omitempty" json:"page,omitempty"`
	Size *int `form:"size,omitempty" json:"size,omitempty"`
}

// GetAccessRequestsParams defines parameters for GetAccessRequests.
type GetAccessRequestsParams struct {
	// TargetUserId Filters requests by the ID of the target user.
	TargetUserId *string `form:"target_user_id,omitempty" json:"target_user_id,omitempty"`

	// RequesterUserId Filters requests by the ID of the requester user.
	RequesterUserId *string `form:"requester_user_id,omitempty" json:"requester_user_id,omitempty"`

	// UserId Filters requests by the ID of the user.
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// Statuses Filters requests by their status.
	Statuses *[]SupportRequestStatus `form:"statuses,omitempty" json:"statuses,omitempty"`
	Page     *int                    `form:"page,omitempty" json:"page,omitempty"`
	Size     *int                    `form:"size,omitempty" json:"size,omitempty"`
}

// GetAccessRequestParams defines parameters for GetAccessRequest.
type GetAccessRequestParams struct {
	Page *int `form:"page,omitempty" json:"page,omitempty"`
	Size *int `form:"size,omitempty" json:"size,omitempty"`
}

// GetAppStoreAppsParams defines parameters for GetAppStoreApps.
type GetAppStoreAppsParams struct {
	// AppClassId Filters apps by the ID of the service (i.e. okta.com). This parameter also requires app_instance_id to be included.
	AppClassId *string `form:"app_class_id,omitempty" json:"app_class_id,omitempty"`

	// AppInstanceId Filters apps by the ID of the instance from the service (app_class_id) from the service.This parameter also requires app_class_id to be included.
	AppInstanceId *string `form:"app_instance_id,omitempty" json:"app_instance_id,omitempty"`

	// AppId Filters apps by the ID of the app.
	AppId *string `form:"app_id,omitempty" json:"app_id,omitempty"`

	// NameSearch Filters apps by name. This parameter requires a domain_id to be included.
	NameSearch *string `form:"name_search,omitempty" json:"name_search,omitempty"`

	// ExactMatch Filters apps by name. This parameter requires a domain_id to be included.
	ExactMatch *bool `form:"exact_match,omitempty" json:"exact_match,omitempty"`
	Page       *int  `form:"page,omitempty" json:"page,omitempty"`
	Size       *int  `form:"size,omitempty" json:"size,omitempty"`
}

// GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetParams defines parameters for GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGet.
type GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetParams struct {
	// AppClassId Filters preapproval rules by the ID of the service they belong to (i.e. okta.com). This parameter also requires app_instance_id to be included.
	AppClassId *string `form:"app_class_id,omitempty" json:"app_class_id,omitempty"`

	// AppInstanceId Filters preapproval rules by the ID of the instance (app_class_id) to which they belong. This parameter also requires app_class_id to be included.
	AppInstanceId *string `form:"app_instance_id,omitempty" json:"app_instance_id,omitempty"`

	// AppId Filters preapproval rules by the ID of the app they belong to them.
	AppId *string `form:"app_id,omitempty" json:"app_id,omitempty"`
	Page  *int    `form:"page,omitempty" json:"page,omitempty"`
	Size  *int    `form:"size,omitempty" json:"size,omitempty"`
}

// GetAppstorePermissionsForAppAppstoreRequestablePermissionsGetParams defines parameters for GetAppstorePermissionsForAppAppstoreRequestablePermissionsGet.
type GetAppstorePermissionsForAppAppstoreRequestablePermissionsGetParams struct {
	// AppClassId Filters requestable permissions by the ID of the service they belong to (i.e. okta.com). This parameter also requires app_instance_id to be included.
	AppClassId *string `form:"app_class_id,omitempty" json:"app_class_id,omitempty"`

	// AppInstanceId Filters requestable permissions by the ID of the instance (app_class_id) to which they belong. This parameter also requires app_class_id to be included.
	AppInstanceId *string `form:"app_instance_id,omitempty" json:"app_instance_id,omitempty"`

	// AppId Filters requestable permissions by the ID of the app they belong to them.
	AppId *string `form:"app_id,omitempty" json:"app_id,omitempty"`

	// SearchTerm
	//     Searches permissions by any of the permission's group name,
	//     request configuration name, or specific integration ID.
	SearchTerm *string `form:"search_term,omitempty" json:"search_term,omitempty"`

	// ExactMatch Search filter should be an exact match.
	ExactMatch *bool `form:"exact_match,omitempty" json:"exact_match,omitempty"`

	// InAppStore
	//     Filters permissions by visibility in the AppStore.
	InAppStore *bool `form:"in_app_store,omitempty" json:"in_app_store,omitempty"`
	Page       *int  `form:"page,omitempty" json:"page,omitempty"`
	Size       *int  `form:"size,omitempty" json:"size,omitempty"`
}

// CreateFoundDocumentMultipartBody defines parameters for CreateFoundDocument.
type CreateFoundDocumentMultipartBody struct {
	// EndDate The end date of the attached contract
	EndDate *openapi_types.Date `json:"end_date,omitempty"`

	// Files A list of files related to a vendor agreement. For example, the Order Form, Quote, MSA, or Terms and Conditions.
	Files []openapi_types.File `json:"files"`

	// SourceAppId The ID of the app that sourced this document. For example, if you are using this API to create a custom Google Drive integration, you might include the ID for the Google Workspaceapp in Lumos. This determines which app's logo is displayed in Lumos.
	SourceAppId *string `json:"source_app_id,omitempty"`

	// StartDate The start date of the attached contract
	StartDate *openapi_types.Date `json:"start_date,omitempty"`

	// UniqueIdentifier A unique identifier for the contract being uploaded. This can be an ID from an external system like Coupa, an internal ID such as a PO number, or simply the name of the file.
	UniqueIdentifier string `json:"unique_identifier"`

	// VendorName The name of the vendor associated with this document
	VendorName *string `json:"vendor_name,omitempty"`
}

// GetGroupsParams defines parameters for GetGroups.
type GetGroupsParams struct {
	IntegrationSpecificId *string `form:"integration_specific_id,omitempty" json:"integration_specific_id,omitempty"`
	Name                  *string `form:"name,omitempty" json:"name,omitempty"`
	ExactMatch            *bool   `form:"exact_match,omitempty" json:"exact_match,omitempty"`
	AppId                 *string `form:"app_id,omitempty" json:"app_id,omitempty"`
	Page                  *int    `form:"page,omitempty" json:"page,omitempty"`
	Size                  *int    `form:"size,omitempty" json:"size,omitempty"`
}

// GetGroupMembershipParams defines parameters for GetGroupMembership.
type GetGroupMembershipParams struct {
	Page *int `form:"page,omitempty" json:"page,omitempty"`
	Size *int `form:"size,omitempty" json:"size,omitempty"`
}

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	SearchTerm *string `form:"search_term,omitempty" json:"search_term,omitempty"`
	ExactMatch *bool   `form:"exact_match,omitempty" json:"exact_match,omitempty"`
	Page       *int    `form:"page,omitempty" json:"page,omitempty"`
	Size       *int    `form:"size,omitempty" json:"size,omitempty"`
}

// CurrentUserParams defines parameters for CurrentUser.
type CurrentUserParams struct {
	Page *int `form:"page,omitempty" json:"page,omitempty"`
	Size *int `form:"size,omitempty" json:"size,omitempty"`
}

// ListVendorAgreementsParams defines parameters for ListVendorAgreements.
type ListVendorAgreementsParams struct {
	Page *int `form:"page,omitempty" json:"page,omitempty"`
	Size *int `form:"size,omitempty" json:"size,omitempty"`
}

// PostAccountsJSONRequestBody defines body for PostAccounts for application/json ContentType.
type PostAccountsJSONRequestBody = AccountsUploadInput

// ActivityRecordsJSONRequestBody defines body for ActivityRecords for application/json ContentType.
type ActivityRecordsJSONRequestBody = ActivityRecordInput

// CreateAppJSONRequestBody defines body for CreateApp for application/json ContentType.
type CreateAppJSONRequestBody = AppInputCreate

// CreateAccessRequestJSONRequestBody defines body for CreateAccessRequest for application/json ContentType.
type CreateAccessRequestJSONRequestBody = CreateAccessRequestInput

// UpdateAppStoreAppSettingsJSONRequestBody defines body for UpdateAppStoreAppSettings for application/json ContentType.
type UpdateAppStoreAppSettingsJSONRequestBody = AppStoreAppSettingsInput

// CreatePreApprovalRuleAppstorePreApprovalRulesPostJSONRequestBody defines body for CreatePreApprovalRuleAppstorePreApprovalRulesPost for application/json ContentType.
type CreatePreApprovalRuleAppstorePreApprovalRulesPostJSONRequestBody = PreApprovalRuleInput

// UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchJSONRequestBody defines body for UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatch for application/json ContentType.
type UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchJSONRequestBody = PreApprovalRuleUpdateInput

// CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostJSONRequestBody defines body for CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPost for application/json ContentType.
type CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostJSONRequestBody = RequestablePermissionInput

// UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchJSONRequestBody defines body for UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatch for application/json ContentType.
type UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchJSONRequestBody = RequestablePermissionInputUpdate

// CreateFoundDocumentJSONRequestBody defines body for CreateFoundDocument for application/json ContentType.
type CreateFoundDocumentJSONRequestBody = FoundDocumentsUpload

// CreateFoundDocumentMultipartRequestBody defines body for CreateFoundDocument for multipart/form-data ContentType.
type CreateFoundDocumentMultipartRequestBody CreateFoundDocumentMultipartBody

// CreateOrderJSONRequestBody defines body for CreateOrder for application/json ContentType.
type CreateOrderJSONRequestBody = OrderInput

// ProcessAirbaseMilestoneEventJSONRequestBody defines body for ProcessAirbaseMilestoneEvent for application/json ContentType.
type ProcessAirbaseMilestoneEventJSONRequestBody = AirbaseMilestoneEvent

// AsValidationErrorLoc0 returns the union data inside the ValidationError_Loc_Item as a ValidationErrorLoc0
func (t ValidationError_Loc_Item) AsValidationErrorLoc0() (ValidationErrorLoc0, error) {
	var body ValidationErrorLoc0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValidationErrorLoc0 overwrites any union data inside the ValidationError_Loc_Item as the provided ValidationErrorLoc0
func (t *ValidationError_Loc_Item) FromValidationErrorLoc0(v ValidationErrorLoc0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValidationErrorLoc0 performs a merge with any union data inside the ValidationError_Loc_Item, using the provided ValidationErrorLoc0
func (t *ValidationError_Loc_Item) MergeValidationErrorLoc0(v ValidationErrorLoc0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsValidationErrorLoc1 returns the union data inside the ValidationError_Loc_Item as a ValidationErrorLoc1
func (t ValidationError_Loc_Item) AsValidationErrorLoc1() (ValidationErrorLoc1, error) {
	var body ValidationErrorLoc1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValidationErrorLoc1 overwrites any union data inside the ValidationError_Loc_Item as the provided ValidationErrorLoc1
func (t *ValidationError_Loc_Item) FromValidationErrorLoc1(v ValidationErrorLoc1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValidationErrorLoc1 performs a merge with any union data inside the ValidationError_Loc_Item, using the provided ValidationErrorLoc1
func (t *ValidationError_Loc_Item) MergeValidationErrorLoc1(v ValidationErrorLoc1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ValidationError_Loc_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ValidationError_Loc_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAccounts request
	GetAccounts(ctx context.Context, params *GetAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAccountsWithBody request with any body
	PostAccountsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAccounts(ctx context.Context, body PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUploadJobState request
	GetUploadJobState(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActivityLogs request
	GetActivityLogs(ctx context.Context, params *GetActivityLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivityRecordsWithBody request with any body
	ActivityRecordsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActivityRecords(ctx context.Context, body ActivityRecordsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActivityRecordsJobState request
	GetActivityRecordsJobState(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListApps request
	ListApps(ctx context.Context, params *ListAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAppWithBody request with any body
	CreateAppWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApp(ctx context.Context, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApp request
	GetApp(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAccessRequestWithBody request with any body
	CreateAccessRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAccessRequest(ctx context.Context, body CreateAccessRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccessRequests request
	GetAccessRequests(ctx context.Context, params *GetAccessRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccessRequest request
	GetAccessRequest(ctx context.Context, accessRequestId string, params *GetAccessRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppStoreApps request
	GetAppStoreApps(ctx context.Context, params *GetAppStoreAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppStoreApp request
	GetAppStoreApp(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppStoreAppSettings request
	GetAppStoreAppSettings(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAppStoreAppSettingsWithBody request with any body
	UpdateAppStoreAppSettingsWithBody(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAppStoreAppSettings(ctx context.Context, appId string, body UpdateAppStoreAppSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGet request
	GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGet(ctx context.Context, params *GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePreApprovalRuleAppstorePreApprovalRulesPostWithBody request with any body
	CreatePreApprovalRuleAppstorePreApprovalRulesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePreApprovalRuleAppstorePreApprovalRulesPost(ctx context.Context, body CreatePreApprovalRuleAppstorePreApprovalRulesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGet request
	GetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGet(ctx context.Context, preApprovalRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchWithBody request with any body
	UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchWithBody(ctx context.Context, preApprovalRuleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatch(ctx context.Context, preApprovalRuleId string, body UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppstorePermissionsForAppAppstoreRequestablePermissionsGet request
	GetAppstorePermissionsForAppAppstoreRequestablePermissionsGet(ctx context.Context, params *GetAppstorePermissionsForAppAppstoreRequestablePermissionsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostWithBody request with any body
	CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPost(ctx context.Context, body CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDelete request
	DeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDelete(ctx context.Context, permissionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGet request
	GetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGet(ctx context.Context, permissionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchWithBody request with any body
	UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchWithBody(ctx context.Context, permissionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatch(ctx context.Context, permissionId string, body UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LumosArt request
	LumosArt(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFoundDocumentWithBody request with any body
	CreateFoundDocumentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFoundDocument(ctx context.Context, body CreateFoundDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroups request
	GetGroups(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroup request
	GetGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupMembership request
	GetGroupMembership(ctx context.Context, groupId string, params *GetGroupMembershipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LumosLivenessCheck request
	LumosLivenessCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInlineWebhooksInlineWebhooksGet request
	GetInlineWebhooksInlineWebhooksGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrderWithBody request with any body
	CreateOrderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrder(ctx context.Context, body CreateOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CurrentUser request
	CurrentUser(ctx context.Context, params *CurrentUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListVendorAgreements request
	ListVendorAgreements(ctx context.Context, params *ListVendorAgreementsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessAirbaseMilestoneEventWithBody request with any body
	ProcessAirbaseMilestoneEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProcessAirbaseMilestoneEvent(ctx context.Context, body ProcessAirbaseMilestoneEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAccounts(ctx context.Context, params *GetAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAccountsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAccountsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAccounts(ctx context.Context, body PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAccountsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUploadJobState(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUploadJobStateRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActivityLogs(ctx context.Context, params *GetActivityLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivityLogsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivityRecordsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivityRecordsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivityRecords(ctx context.Context, body ActivityRecordsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivityRecordsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActivityRecordsJobState(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivityRecordsJobStateRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListApps(ctx context.Context, params *ListAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApp(ctx context.Context, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApp(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppRequest(c.Server, appId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccessRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccessRequestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccessRequest(ctx context.Context, body CreateAccessRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccessRequestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccessRequests(ctx context.Context, params *GetAccessRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccessRequestsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccessRequest(ctx context.Context, accessRequestId string, params *GetAccessRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccessRequestRequest(c.Server, accessRequestId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppStoreApps(ctx context.Context, params *GetAppStoreAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppStoreAppsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppStoreApp(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppStoreAppRequest(c.Server, appId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppStoreAppSettings(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppStoreAppSettingsRequest(c.Server, appId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppStoreAppSettingsWithBody(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppStoreAppSettingsRequestWithBody(c.Server, appId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppStoreAppSettings(ctx context.Context, appId string, body UpdateAppStoreAppSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppStoreAppSettingsRequest(c.Server, appId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGet(ctx context.Context, params *GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePreApprovalRuleAppstorePreApprovalRulesPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePreApprovalRuleAppstorePreApprovalRulesPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePreApprovalRuleAppstorePreApprovalRulesPost(ctx context.Context, body CreatePreApprovalRuleAppstorePreApprovalRulesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePreApprovalRuleAppstorePreApprovalRulesPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGet(ctx context.Context, preApprovalRuleId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGetRequest(c.Server, preApprovalRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchWithBody(ctx context.Context, preApprovalRuleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchRequestWithBody(c.Server, preApprovalRuleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatch(ctx context.Context, preApprovalRuleId string, body UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchRequest(c.Server, preApprovalRuleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppstorePermissionsForAppAppstoreRequestablePermissionsGet(ctx context.Context, params *GetAppstorePermissionsForAppAppstoreRequestablePermissionsGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppstorePermissionsForAppAppstoreRequestablePermissionsGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPost(ctx context.Context, body CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDelete(ctx context.Context, permissionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDeleteRequest(c.Server, permissionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGet(ctx context.Context, permissionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGetRequest(c.Server, permissionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchWithBody(ctx context.Context, permissionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchRequestWithBody(c.Server, permissionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatch(ctx context.Context, permissionId string, body UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchRequest(c.Server, permissionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LumosArt(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLumosArtRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFoundDocumentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFoundDocumentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFoundDocument(ctx context.Context, body CreateFoundDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFoundDocumentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroups(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroup(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupMembership(ctx context.Context, groupId string, params *GetGroupMembershipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupMembershipRequest(c.Server, groupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LumosLivenessCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLumosLivenessCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInlineWebhooksInlineWebhooksGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInlineWebhooksInlineWebhooksGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrderRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrder(ctx context.Context, body CreateOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrderRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CurrentUser(ctx context.Context, params *CurrentUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCurrentUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListVendorAgreements(ctx context.Context, params *ListVendorAgreementsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListVendorAgreementsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessAirbaseMilestoneEventWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessAirbaseMilestoneEventRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessAirbaseMilestoneEvent(ctx context.Context, body ProcessAirbaseMilestoneEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessAirbaseMilestoneEventRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAccountsRequest generates requests for GetAccounts
func NewGetAccountsRequest(server string, params *GetAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppId != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app_id", runtime.ParamLocationQuery, *params.AppId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Page != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Size != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAccountsRequest calls the generic PostAccounts builder with application/json body
func NewPostAccountsRequest(server string, body PostAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAccountsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostAccountsRequestWithBody generates requests for PostAccounts with any type of body
func NewPostAccountsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUploadJobStateRequest generates requests for GetUploadJobState
func NewGetUploadJobStateRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/upload/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActivityLogsRequest generates requests for GetActivityLogs
func NewGetActivityLogsRequest(server string, params *GetActivityLogsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activity_logs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Since != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Until != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Limit != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Offset != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivityRecordsRequest calls the generic ActivityRecords builder with application/json body
func NewActivityRecordsRequest(server string, body ActivityRecordsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActivityRecordsRequestWithBody(server, "application/json", bodyReader)
}

// NewActivityRecordsRequestWithBody generates requests for ActivityRecords with any type of body
func NewActivityRecordsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activity_records")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetActivityRecordsJobStateRequest generates requests for GetActivityRecordsJobState
func NewGetActivityRecordsJobStateRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activity_records/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAppsRequest generates requests for ListApps
func NewListAppsRequest(server string, params *ListAppsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Size != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAppRequest calls the generic CreateApp builder with application/json body
func NewCreateAppRequest(server string, body CreateAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAppRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAppRequestWithBody generates requests for CreateApp with any type of body
func NewCreateAppRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAppRequest generates requests for GetApp
func NewGetAppRequest(server string, appId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_id", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAccessRequestRequest calls the generic CreateAccessRequest builder with application/json body
func NewCreateAccessRequestRequest(server string, body CreateAccessRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAccessRequestRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAccessRequestRequestWithBody generates requests for CreateAccessRequest with any type of body
func NewCreateAccessRequestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/appstore/access_request")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAccessRequestsRequest generates requests for GetAccessRequests
func NewGetAccessRequestsRequest(server string, params *GetAccessRequestsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/appstore/access_requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TargetUserId != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_user_id", runtime.ParamLocationQuery, *params.TargetUserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.RequesterUserId != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requester_user_id", runtime.ParamLocationQuery, *params.RequesterUserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.UserId != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Statuses != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statuses", runtime.ParamLocationQuery, *params.Statuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Page != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Size != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccessRequestRequest generates requests for GetAccessRequest
func NewGetAccessRequestRequest(server string, accessRequestId string, params *GetAccessRequestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "access_request_id", runtime.ParamLocationPath, accessRequestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/appstore/access_requests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Size != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppStoreAppsRequest generates requests for GetAppStoreApps
func NewGetAppStoreAppsRequest(server string, params *GetAppStoreAppsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/appstore/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppClassId != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app_class_id", runtime.ParamLocationQuery, *params.AppClassId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.AppInstanceId != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app_instance_id", runtime.ParamLocationQuery, *params.AppInstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.AppId != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app_id", runtime.ParamLocationQuery, *params.AppId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.NameSearch != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name_search", runtime.ParamLocationQuery, *params.NameSearch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.ExactMatch != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exact_match", runtime.ParamLocationQuery, *params.ExactMatch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Page != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Size != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppStoreAppRequest generates requests for GetAppStoreApp
func NewGetAppStoreAppRequest(server string, appId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_id", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/appstore/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppStoreAppSettingsRequest generates requests for GetAppStoreAppSettings
func NewGetAppStoreAppSettingsRequest(server string, appId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_id", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/appstore/apps/%s/settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAppStoreAppSettingsRequest calls the generic UpdateAppStoreAppSettings builder with application/json body
func NewUpdateAppStoreAppSettingsRequest(server string, appId string, body UpdateAppStoreAppSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAppStoreAppSettingsRequestWithBody(server, appId, "application/json", bodyReader)
}

// NewUpdateAppStoreAppSettingsRequestWithBody generates requests for UpdateAppStoreAppSettings with any type of body
func NewUpdateAppStoreAppSettingsRequestWithBody(server string, appId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_id", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/appstore/apps/%s/settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetRequest generates requests for GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGet
func NewGetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetRequest(server string, params *GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/appstore/pre_approval_rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppClassId != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app_class_id", runtime.ParamLocationQuery, *params.AppClassId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.AppInstanceId != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app_instance_id", runtime.ParamLocationQuery, *params.AppInstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.AppId != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app_id", runtime.ParamLocationQuery, *params.AppId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Page != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Size != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePreApprovalRuleAppstorePreApprovalRulesPostRequest calls the generic CreatePreApprovalRuleAppstorePreApprovalRulesPost builder with application/json body
func NewCreatePreApprovalRuleAppstorePreApprovalRulesPostRequest(server string, body CreatePreApprovalRuleAppstorePreApprovalRulesPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePreApprovalRuleAppstorePreApprovalRulesPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePreApprovalRuleAppstorePreApprovalRulesPostRequestWithBody generates requests for CreatePreApprovalRuleAppstorePreApprovalRulesPost with any type of body
func NewCreatePreApprovalRuleAppstorePreApprovalRulesPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/appstore/pre_approval_rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGetRequest generates requests for GetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGet
func NewGetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGetRequest(server string, preApprovalRuleId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pre_approval_rule_id", runtime.ParamLocationPath, preApprovalRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/appstore/pre_approval_rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchRequest calls the generic UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatch builder with application/json body
func NewUpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchRequest(server string, preApprovalRuleId string, body UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchRequestWithBody(server, preApprovalRuleId, "application/json", bodyReader)
}

// NewUpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchRequestWithBody generates requests for UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatch with any type of body
func NewUpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchRequestWithBody(server string, preApprovalRuleId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pre_approval_rule_id", runtime.ParamLocationPath, preApprovalRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/appstore/pre_approval_rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAppstorePermissionsForAppAppstoreRequestablePermissionsGetRequest generates requests for GetAppstorePermissionsForAppAppstoreRequestablePermissionsGet
func NewGetAppstorePermissionsForAppAppstoreRequestablePermissionsGetRequest(server string, params *GetAppstorePermissionsForAppAppstoreRequestablePermissionsGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/appstore/requestable_permissions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AppClassId != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app_class_id", runtime.ParamLocationQuery, *params.AppClassId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.AppInstanceId != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app_instance_id", runtime.ParamLocationQuery, *params.AppInstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.AppId != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app_id", runtime.ParamLocationQuery, *params.AppId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.SearchTerm != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_term", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.ExactMatch != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exact_match", runtime.ParamLocationQuery, *params.ExactMatch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.InAppStore != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "in_app_store", runtime.ParamLocationQuery, *params.InAppStore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Page != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Size != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostRequest calls the generic CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPost builder with application/json body
func NewCreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostRequest(server string, body CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostRequestWithBody generates requests for CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPost with any type of body
func NewCreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/appstore/requestable_permissions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDeleteRequest generates requests for DeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDelete
func NewDeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDeleteRequest(server string, permissionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "permission_id", runtime.ParamLocationPath, permissionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/appstore/requestable_permissions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGetRequest generates requests for GetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGet
func NewGetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGetRequest(server string, permissionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "permission_id", runtime.ParamLocationPath, permissionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/appstore/requestable_permissions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchRequest calls the generic UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatch builder with application/json body
func NewUpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchRequest(server string, permissionId string, body UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchRequestWithBody(server, permissionId, "application/json", bodyReader)
}

// NewUpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchRequestWithBody generates requests for UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatch with any type of body
func NewUpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchRequestWithBody(server string, permissionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "permission_id", runtime.ParamLocationPath, permissionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/appstore/requestable_permissions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLumosArtRequest generates requests for LumosArt
func NewLumosArtRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/art")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFoundDocumentRequest calls the generic CreateFoundDocument builder with application/json body
func NewCreateFoundDocumentRequest(server string, body CreateFoundDocumentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFoundDocumentRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateFoundDocumentRequestWithBody generates requests for CreateFoundDocument with any type of body
func NewCreateFoundDocumentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/found_documents")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGroupsRequest generates requests for GetGroups
func NewGetGroupsRequest(server string, params *GetGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IntegrationSpecificId != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "integration_specific_id", runtime.ParamLocationQuery, *params.IntegrationSpecificId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Name != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.ExactMatch != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exact_match", runtime.ParamLocationQuery, *params.ExactMatch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.AppId != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app_id", runtime.ParamLocationQuery, *params.AppId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Page != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Size != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupRequest generates requests for GetGroup
func NewGetGroupRequest(server string, groupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupMembershipRequest generates requests for GetGroupMembership
func NewGetGroupMembershipRequest(server string, groupId string, params *GetGroupMembershipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Size != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLumosLivenessCheckRequest generates requests for LumosLivenessCheck
func NewLumosLivenessCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInlineWebhooksInlineWebhooksGetRequest generates requests for GetInlineWebhooksInlineWebhooksGet
func NewGetInlineWebhooksInlineWebhooksGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/inline_webhooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrderRequest calls the generic CreateOrder builder with application/json body
func NewCreateOrderRequest(server string, body CreateOrderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrderRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateOrderRequestWithBody generates requests for CreateOrder with any type of body
func NewCreateOrderRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, params *ListUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SearchTerm != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search_term", runtime.ParamLocationQuery, *params.SearchTerm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.ExactMatch != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exact_match", runtime.ParamLocationQuery, *params.ExactMatch); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Page != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Size != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCurrentUserRequest generates requests for CurrentUser
func NewCurrentUserRequest(server string, params *CurrentUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/current")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Size != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListVendorAgreementsRequest generates requests for ListVendorAgreements
func NewListVendorAgreementsRequest(server string, params *ListVendorAgreementsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/vendor_agreements")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		if params.Size != nil {
			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProcessAirbaseMilestoneEventRequest calls the generic ProcessAirbaseMilestoneEvent builder with application/json body
func NewProcessAirbaseMilestoneEventRequest(server string, body ProcessAirbaseMilestoneEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProcessAirbaseMilestoneEventRequestWithBody(server, "application/json", bodyReader)
}

// NewProcessAirbaseMilestoneEventRequestWithBody generates requests for ProcessAirbaseMilestoneEvent with any type of body
func NewProcessAirbaseMilestoneEventRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/airbase/milestone_event")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAccountsWithResponse request
	GetAccountsWithResponse(ctx context.Context, params *GetAccountsParams, reqEditors ...RequestEditorFn) (*GetAccountsResponse, error)

	// PostAccountsWithBodyWithResponse request with any body
	PostAccountsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAccountsResponse, error)

	PostAccountsWithResponse(ctx context.Context, body PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAccountsResponse, error)

	// GetUploadJobStateWithResponse request
	GetUploadJobStateWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*GetUploadJobStateResponse, error)

	// GetActivityLogsWithResponse request
	GetActivityLogsWithResponse(ctx context.Context, params *GetActivityLogsParams, reqEditors ...RequestEditorFn) (*GetActivityLogsResponse, error)

	// ActivityRecordsWithBodyWithResponse request with any body
	ActivityRecordsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivityRecordsResponse, error)

	ActivityRecordsWithResponse(ctx context.Context, body ActivityRecordsJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivityRecordsResponse, error)

	// GetActivityRecordsJobStateWithResponse request
	GetActivityRecordsJobStateWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*GetActivityRecordsJobStateResponse, error)

	// ListAppsWithResponse request
	ListAppsWithResponse(ctx context.Context, params *ListAppsParams, reqEditors ...RequestEditorFn) (*ListAppsResponse, error)

	// CreateAppWithBodyWithResponse request with any body
	CreateAppWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppResponse, error)

	CreateAppWithResponse(ctx context.Context, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppResponse, error)

	// GetAppWithResponse request
	GetAppWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*GetAppResponse, error)

	// CreateAccessRequestWithBodyWithResponse request with any body
	CreateAccessRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccessRequestResponse, error)

	CreateAccessRequestWithResponse(ctx context.Context, body CreateAccessRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccessRequestResponse, error)

	// GetAccessRequestsWithResponse request
	GetAccessRequestsWithResponse(ctx context.Context, params *GetAccessRequestsParams, reqEditors ...RequestEditorFn) (*GetAccessRequestsResponse, error)

	// GetAccessRequestWithResponse request
	GetAccessRequestWithResponse(ctx context.Context, accessRequestId string, params *GetAccessRequestParams, reqEditors ...RequestEditorFn) (*GetAccessRequestResponse, error)

	// GetAppStoreAppsWithResponse request
	GetAppStoreAppsWithResponse(ctx context.Context, params *GetAppStoreAppsParams, reqEditors ...RequestEditorFn) (*GetAppStoreAppsResponse, error)

	// GetAppStoreAppWithResponse request
	GetAppStoreAppWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*GetAppStoreAppResponse, error)

	// GetAppStoreAppSettingsWithResponse request
	GetAppStoreAppSettingsWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*GetAppStoreAppSettingsResponse, error)

	// UpdateAppStoreAppSettingsWithBodyWithResponse request with any body
	UpdateAppStoreAppSettingsWithBodyWithResponse(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppStoreAppSettingsResponse, error)

	UpdateAppStoreAppSettingsWithResponse(ctx context.Context, appId string, body UpdateAppStoreAppSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppStoreAppSettingsResponse, error)

	// GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetWithResponse request
	GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetWithResponse(ctx context.Context, params *GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetParams, reqEditors ...RequestEditorFn) (*GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetResponse, error)

	// CreatePreApprovalRuleAppstorePreApprovalRulesPostWithBodyWithResponse request with any body
	CreatePreApprovalRuleAppstorePreApprovalRulesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePreApprovalRuleAppstorePreApprovalRulesPostResponse, error)

	CreatePreApprovalRuleAppstorePreApprovalRulesPostWithResponse(ctx context.Context, body CreatePreApprovalRuleAppstorePreApprovalRulesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePreApprovalRuleAppstorePreApprovalRulesPostResponse, error)

	// GetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGetWithResponse request
	GetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGetWithResponse(ctx context.Context, preApprovalRuleId string, reqEditors ...RequestEditorFn) (*GetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGetResponse, error)

	// UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchWithBodyWithResponse request with any body
	UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchWithBodyWithResponse(ctx context.Context, preApprovalRuleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchResponse, error)

	UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchWithResponse(ctx context.Context, preApprovalRuleId string, body UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchResponse, error)

	// GetAppstorePermissionsForAppAppstoreRequestablePermissionsGetWithResponse request
	GetAppstorePermissionsForAppAppstoreRequestablePermissionsGetWithResponse(ctx context.Context, params *GetAppstorePermissionsForAppAppstoreRequestablePermissionsGetParams, reqEditors ...RequestEditorFn) (*GetAppstorePermissionsForAppAppstoreRequestablePermissionsGetResponse, error)

	// CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostWithBodyWithResponse request with any body
	CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostResponse, error)

	CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostWithResponse(ctx context.Context, body CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostResponse, error)

	// DeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDeleteWithResponse request
	DeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDeleteWithResponse(ctx context.Context, permissionId string, reqEditors ...RequestEditorFn) (*DeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDeleteResponse, error)

	// GetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGetWithResponse request
	GetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGetWithResponse(ctx context.Context, permissionId string, reqEditors ...RequestEditorFn) (*GetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGetResponse, error)

	// UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchWithBodyWithResponse request with any body
	UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchWithBodyWithResponse(ctx context.Context, permissionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchResponse, error)

	UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchWithResponse(ctx context.Context, permissionId string, body UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchResponse, error)

	// LumosArtWithResponse request
	LumosArtWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LumosArtResponse, error)

	// CreateFoundDocumentWithBodyWithResponse request with any body
	CreateFoundDocumentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFoundDocumentResponse, error)

	CreateFoundDocumentWithResponse(ctx context.Context, body CreateFoundDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFoundDocumentResponse, error)

	// GetGroupsWithResponse request
	GetGroupsWithResponse(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*GetGroupsResponse, error)

	// GetGroupWithResponse request
	GetGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupResponse, error)

	// GetGroupMembershipWithResponse request
	GetGroupMembershipWithResponse(ctx context.Context, groupId string, params *GetGroupMembershipParams, reqEditors ...RequestEditorFn) (*GetGroupMembershipResponse, error)

	// LumosLivenessCheckWithResponse request
	LumosLivenessCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LumosLivenessCheckResponse, error)

	// GetInlineWebhooksInlineWebhooksGetWithResponse request
	GetInlineWebhooksInlineWebhooksGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInlineWebhooksInlineWebhooksGetResponse, error)

	// CreateOrderWithBodyWithResponse request with any body
	CreateOrderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrderResponse, error)

	CreateOrderWithResponse(ctx context.Context, body CreateOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrderResponse, error)

	// ListUsersWithResponse request
	ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// CurrentUserWithResponse request
	CurrentUserWithResponse(ctx context.Context, params *CurrentUserParams, reqEditors ...RequestEditorFn) (*CurrentUserResponse, error)

	// GetUserWithResponse request
	GetUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// ListVendorAgreementsWithResponse request
	ListVendorAgreementsWithResponse(ctx context.Context, params *ListVendorAgreementsParams, reqEditors ...RequestEditorFn) (*ListVendorAgreementsResponse, error)

	// ProcessAirbaseMilestoneEventWithBodyWithResponse request with any body
	ProcessAirbaseMilestoneEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessAirbaseMilestoneEventResponse, error)

	ProcessAirbaseMilestoneEventWithResponse(ctx context.Context, body ProcessAirbaseMilestoneEventJSONRequestBody, reqEditors ...RequestEditorFn) (*ProcessAirbaseMilestoneEventResponse, error)
}

type GetAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageAccount
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JobStateOutput
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r PostAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUploadJobStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JobStateOutput
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetUploadJobStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUploadJobStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActivityLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LimitOffsetPageActivityLog
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetActivityLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivityLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivityRecordsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActivityRecordOutput
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ActivityRecordsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivityRecordsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActivityRecordsJobStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncTaskOutput
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetActivityRecordsJobStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivityRecordsJobStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageApp
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ListAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *App
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAccessRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]AccessRequest
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateAccessRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAccessRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccessRequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageAccessRequest
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetAccessRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccessRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccessRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccessRequest
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetAccessRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccessRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppStoreAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageAppStoreApp
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetAppStoreAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppStoreAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppStoreAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppStoreApp
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetAppStoreAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppStoreAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppStoreAppSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppStoreAppSettingsOutput
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetAppStoreAppSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppStoreAppSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAppStoreAppSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppStoreAppSettingsOutput
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UpdateAppStoreAppSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAppStoreAppSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagePreApprovalRuleOutput
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePreApprovalRuleAppstorePreApprovalRulesPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PreApprovalRuleOutput
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreatePreApprovalRuleAppstorePreApprovalRulesPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePreApprovalRuleAppstorePreApprovalRulesPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PreApprovalRuleOutput
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PreApprovalRuleOutput
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppstorePermissionsForAppAppstoreRequestablePermissionsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageRequestablePermissionOutput
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetAppstorePermissionsForAppAppstoreRequestablePermissionsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppstorePermissionsForAppAppstoreRequestablePermissionsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RequestablePermissionOutput
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r DeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestablePermissionOutput
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestablePermissionOutput
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LumosArtResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LumosArtResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LumosArtResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFoundDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateFoundDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFoundDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageGroup
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupMembershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageUser
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetGroupMembershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupMembershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LumosLivenessCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r LumosLivenessCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LumosLivenessCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInlineWebhooksInlineWebhooksGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]InlineWebhook
}

// Status returns HTTPResponse.Status
func (r GetInlineWebhooksInlineWebhooksGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInlineWebhooksInlineWebhooksGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *interface{}
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateOrderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageUser
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CurrentUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CurrentUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CurrentUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListVendorAgreementsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageVendorAgreement
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ListVendorAgreementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVendorAgreementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessAirbaseMilestoneEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ProcessAirbaseMilestoneEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessAirbaseMilestoneEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAccountsWithResponse request returning *GetAccountsResponse
func (c *ClientWithResponses) GetAccountsWithResponse(ctx context.Context, params *GetAccountsParams, reqEditors ...RequestEditorFn) (*GetAccountsResponse, error) {
	rsp, err := c.GetAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountsResponse(rsp)
}

// PostAccountsWithBodyWithResponse request with arbitrary body returning *PostAccountsResponse
func (c *ClientWithResponses) PostAccountsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAccountsResponse, error) {
	rsp, err := c.PostAccountsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAccountsResponse(rsp)
}

func (c *ClientWithResponses) PostAccountsWithResponse(ctx context.Context, body PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAccountsResponse, error) {
	rsp, err := c.PostAccounts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAccountsResponse(rsp)
}

// GetUploadJobStateWithResponse request returning *GetUploadJobStateResponse
func (c *ClientWithResponses) GetUploadJobStateWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*GetUploadJobStateResponse, error) {
	rsp, err := c.GetUploadJobState(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUploadJobStateResponse(rsp)
}

// GetActivityLogsWithResponse request returning *GetActivityLogsResponse
func (c *ClientWithResponses) GetActivityLogsWithResponse(ctx context.Context, params *GetActivityLogsParams, reqEditors ...RequestEditorFn) (*GetActivityLogsResponse, error) {
	rsp, err := c.GetActivityLogs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivityLogsResponse(rsp)
}

// ActivityRecordsWithBodyWithResponse request with arbitrary body returning *ActivityRecordsResponse
func (c *ClientWithResponses) ActivityRecordsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivityRecordsResponse, error) {
	rsp, err := c.ActivityRecordsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivityRecordsResponse(rsp)
}

func (c *ClientWithResponses) ActivityRecordsWithResponse(ctx context.Context, body ActivityRecordsJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivityRecordsResponse, error) {
	rsp, err := c.ActivityRecords(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivityRecordsResponse(rsp)
}

// GetActivityRecordsJobStateWithResponse request returning *GetActivityRecordsJobStateResponse
func (c *ClientWithResponses) GetActivityRecordsJobStateWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*GetActivityRecordsJobStateResponse, error) {
	rsp, err := c.GetActivityRecordsJobState(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivityRecordsJobStateResponse(rsp)
}

// ListAppsWithResponse request returning *ListAppsResponse
func (c *ClientWithResponses) ListAppsWithResponse(ctx context.Context, params *ListAppsParams, reqEditors ...RequestEditorFn) (*ListAppsResponse, error) {
	rsp, err := c.ListApps(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppsResponse(rsp)
}

// CreateAppWithBodyWithResponse request with arbitrary body returning *CreateAppResponse
func (c *ClientWithResponses) CreateAppWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppResponse, error) {
	rsp, err := c.CreateAppWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppResponse(rsp)
}

func (c *ClientWithResponses) CreateAppWithResponse(ctx context.Context, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppResponse, error) {
	rsp, err := c.CreateApp(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppResponse(rsp)
}

// GetAppWithResponse request returning *GetAppResponse
func (c *ClientWithResponses) GetAppWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*GetAppResponse, error) {
	rsp, err := c.GetApp(ctx, appId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppResponse(rsp)
}

// CreateAccessRequestWithBodyWithResponse request with arbitrary body returning *CreateAccessRequestResponse
func (c *ClientWithResponses) CreateAccessRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccessRequestResponse, error) {
	rsp, err := c.CreateAccessRequestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccessRequestResponse(rsp)
}

func (c *ClientWithResponses) CreateAccessRequestWithResponse(ctx context.Context, body CreateAccessRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccessRequestResponse, error) {
	rsp, err := c.CreateAccessRequest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccessRequestResponse(rsp)
}

// GetAccessRequestsWithResponse request returning *GetAccessRequestsResponse
func (c *ClientWithResponses) GetAccessRequestsWithResponse(ctx context.Context, params *GetAccessRequestsParams, reqEditors ...RequestEditorFn) (*GetAccessRequestsResponse, error) {
	rsp, err := c.GetAccessRequests(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccessRequestsResponse(rsp)
}

// GetAccessRequestWithResponse request returning *GetAccessRequestResponse
func (c *ClientWithResponses) GetAccessRequestWithResponse(ctx context.Context, accessRequestId string, params *GetAccessRequestParams, reqEditors ...RequestEditorFn) (*GetAccessRequestResponse, error) {
	rsp, err := c.GetAccessRequest(ctx, accessRequestId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccessRequestResponse(rsp)
}

// GetAppStoreAppsWithResponse request returning *GetAppStoreAppsResponse
func (c *ClientWithResponses) GetAppStoreAppsWithResponse(ctx context.Context, params *GetAppStoreAppsParams, reqEditors ...RequestEditorFn) (*GetAppStoreAppsResponse, error) {
	rsp, err := c.GetAppStoreApps(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppStoreAppsResponse(rsp)
}

// GetAppStoreAppWithResponse request returning *GetAppStoreAppResponse
func (c *ClientWithResponses) GetAppStoreAppWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*GetAppStoreAppResponse, error) {
	rsp, err := c.GetAppStoreApp(ctx, appId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppStoreAppResponse(rsp)
}

// GetAppStoreAppSettingsWithResponse request returning *GetAppStoreAppSettingsResponse
func (c *ClientWithResponses) GetAppStoreAppSettingsWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*GetAppStoreAppSettingsResponse, error) {
	rsp, err := c.GetAppStoreAppSettings(ctx, appId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppStoreAppSettingsResponse(rsp)
}

// UpdateAppStoreAppSettingsWithBodyWithResponse request with arbitrary body returning *UpdateAppStoreAppSettingsResponse
func (c *ClientWithResponses) UpdateAppStoreAppSettingsWithBodyWithResponse(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppStoreAppSettingsResponse, error) {
	rsp, err := c.UpdateAppStoreAppSettingsWithBody(ctx, appId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppStoreAppSettingsResponse(rsp)
}

func (c *ClientWithResponses) UpdateAppStoreAppSettingsWithResponse(ctx context.Context, appId string, body UpdateAppStoreAppSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppStoreAppSettingsResponse, error) {
	rsp, err := c.UpdateAppStoreAppSettings(ctx, appId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppStoreAppSettingsResponse(rsp)
}

// GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetWithResponse request returning *GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetResponse
func (c *ClientWithResponses) GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetWithResponse(ctx context.Context, params *GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetParams, reqEditors ...RequestEditorFn) (*GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetResponse, error) {
	rsp, err := c.GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetResponse(rsp)
}

// CreatePreApprovalRuleAppstorePreApprovalRulesPostWithBodyWithResponse request with arbitrary body returning *CreatePreApprovalRuleAppstorePreApprovalRulesPostResponse
func (c *ClientWithResponses) CreatePreApprovalRuleAppstorePreApprovalRulesPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePreApprovalRuleAppstorePreApprovalRulesPostResponse, error) {
	rsp, err := c.CreatePreApprovalRuleAppstorePreApprovalRulesPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePreApprovalRuleAppstorePreApprovalRulesPostResponse(rsp)
}

func (c *ClientWithResponses) CreatePreApprovalRuleAppstorePreApprovalRulesPostWithResponse(ctx context.Context, body CreatePreApprovalRuleAppstorePreApprovalRulesPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePreApprovalRuleAppstorePreApprovalRulesPostResponse, error) {
	rsp, err := c.CreatePreApprovalRuleAppstorePreApprovalRulesPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePreApprovalRuleAppstorePreApprovalRulesPostResponse(rsp)
}

// GetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGetWithResponse request returning *GetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGetResponse
func (c *ClientWithResponses) GetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGetWithResponse(ctx context.Context, preApprovalRuleId string, reqEditors ...RequestEditorFn) (*GetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGetResponse, error) {
	rsp, err := c.GetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGet(ctx, preApprovalRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGetResponse(rsp)
}

// UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchWithBodyWithResponse request with arbitrary body returning *UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchResponse
func (c *ClientWithResponses) UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchWithBodyWithResponse(ctx context.Context, preApprovalRuleId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchResponse, error) {
	rsp, err := c.UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchWithBody(ctx, preApprovalRuleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchResponse(rsp)
}

func (c *ClientWithResponses) UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchWithResponse(ctx context.Context, preApprovalRuleId string, body UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchResponse, error) {
	rsp, err := c.UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatch(ctx, preApprovalRuleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchResponse(rsp)
}

// GetAppstorePermissionsForAppAppstoreRequestablePermissionsGetWithResponse request returning *GetAppstorePermissionsForAppAppstoreRequestablePermissionsGetResponse
func (c *ClientWithResponses) GetAppstorePermissionsForAppAppstoreRequestablePermissionsGetWithResponse(ctx context.Context, params *GetAppstorePermissionsForAppAppstoreRequestablePermissionsGetParams, reqEditors ...RequestEditorFn) (*GetAppstorePermissionsForAppAppstoreRequestablePermissionsGetResponse, error) {
	rsp, err := c.GetAppstorePermissionsForAppAppstoreRequestablePermissionsGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppstorePermissionsForAppAppstoreRequestablePermissionsGetResponse(rsp)
}

// CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostWithBodyWithResponse request with arbitrary body returning *CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostResponse
func (c *ClientWithResponses) CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostResponse, error) {
	rsp, err := c.CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostResponse(rsp)
}

func (c *ClientWithResponses) CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostWithResponse(ctx context.Context, body CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostResponse, error) {
	rsp, err := c.CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostResponse(rsp)
}

// DeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDeleteWithResponse request returning *DeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDeleteResponse
func (c *ClientWithResponses) DeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDeleteWithResponse(ctx context.Context, permissionId string, reqEditors ...RequestEditorFn) (*DeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDeleteResponse, error) {
	rsp, err := c.DeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDelete(ctx, permissionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDeleteResponse(rsp)
}

// GetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGetWithResponse request returning *GetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGetResponse
func (c *ClientWithResponses) GetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGetWithResponse(ctx context.Context, permissionId string, reqEditors ...RequestEditorFn) (*GetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGetResponse, error) {
	rsp, err := c.GetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGet(ctx, permissionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGetResponse(rsp)
}

// UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchWithBodyWithResponse request with arbitrary body returning *UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchResponse
func (c *ClientWithResponses) UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchWithBodyWithResponse(ctx context.Context, permissionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchResponse, error) {
	rsp, err := c.UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchWithBody(ctx, permissionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchResponse(rsp)
}

func (c *ClientWithResponses) UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchWithResponse(ctx context.Context, permissionId string, body UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchResponse, error) {
	rsp, err := c.UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatch(ctx, permissionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchResponse(rsp)
}

// LumosArtWithResponse request returning *LumosArtResponse
func (c *ClientWithResponses) LumosArtWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LumosArtResponse, error) {
	rsp, err := c.LumosArt(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLumosArtResponse(rsp)
}

// CreateFoundDocumentWithBodyWithResponse request with arbitrary body returning *CreateFoundDocumentResponse
func (c *ClientWithResponses) CreateFoundDocumentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFoundDocumentResponse, error) {
	rsp, err := c.CreateFoundDocumentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFoundDocumentResponse(rsp)
}

func (c *ClientWithResponses) CreateFoundDocumentWithResponse(ctx context.Context, body CreateFoundDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFoundDocumentResponse, error) {
	rsp, err := c.CreateFoundDocument(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFoundDocumentResponse(rsp)
}

// GetGroupsWithResponse request returning *GetGroupsResponse
func (c *ClientWithResponses) GetGroupsWithResponse(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*GetGroupsResponse, error) {
	rsp, err := c.GetGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsResponse(rsp)
}

// GetGroupWithResponse request returning *GetGroupResponse
func (c *ClientWithResponses) GetGroupWithResponse(ctx context.Context, groupId string, reqEditors ...RequestEditorFn) (*GetGroupResponse, error) {
	rsp, err := c.GetGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupResponse(rsp)
}

// GetGroupMembershipWithResponse request returning *GetGroupMembershipResponse
func (c *ClientWithResponses) GetGroupMembershipWithResponse(ctx context.Context, groupId string, params *GetGroupMembershipParams, reqEditors ...RequestEditorFn) (*GetGroupMembershipResponse, error) {
	rsp, err := c.GetGroupMembership(ctx, groupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupMembershipResponse(rsp)
}

// LumosLivenessCheckWithResponse request returning *LumosLivenessCheckResponse
func (c *ClientWithResponses) LumosLivenessCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LumosLivenessCheckResponse, error) {
	rsp, err := c.LumosLivenessCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLumosLivenessCheckResponse(rsp)
}

// GetInlineWebhooksInlineWebhooksGetWithResponse request returning *GetInlineWebhooksInlineWebhooksGetResponse
func (c *ClientWithResponses) GetInlineWebhooksInlineWebhooksGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInlineWebhooksInlineWebhooksGetResponse, error) {
	rsp, err := c.GetInlineWebhooksInlineWebhooksGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInlineWebhooksInlineWebhooksGetResponse(rsp)
}

// CreateOrderWithBodyWithResponse request with arbitrary body returning *CreateOrderResponse
func (c *ClientWithResponses) CreateOrderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrderResponse, error) {
	rsp, err := c.CreateOrderWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrderResponse(rsp)
}

func (c *ClientWithResponses) CreateOrderWithResponse(ctx context.Context, body CreateOrderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrderResponse, error) {
	rsp, err := c.CreateOrder(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrderResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// CurrentUserWithResponse request returning *CurrentUserResponse
func (c *ClientWithResponses) CurrentUserWithResponse(ctx context.Context, params *CurrentUserParams, reqEditors ...RequestEditorFn) (*CurrentUserResponse, error) {
	rsp, err := c.CurrentUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCurrentUserResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// ListVendorAgreementsWithResponse request returning *ListVendorAgreementsResponse
func (c *ClientWithResponses) ListVendorAgreementsWithResponse(ctx context.Context, params *ListVendorAgreementsParams, reqEditors ...RequestEditorFn) (*ListVendorAgreementsResponse, error) {
	rsp, err := c.ListVendorAgreements(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListVendorAgreementsResponse(rsp)
}

// ProcessAirbaseMilestoneEventWithBodyWithResponse request with arbitrary body returning *ProcessAirbaseMilestoneEventResponse
func (c *ClientWithResponses) ProcessAirbaseMilestoneEventWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProcessAirbaseMilestoneEventResponse, error) {
	rsp, err := c.ProcessAirbaseMilestoneEventWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessAirbaseMilestoneEventResponse(rsp)
}

func (c *ClientWithResponses) ProcessAirbaseMilestoneEventWithResponse(ctx context.Context, body ProcessAirbaseMilestoneEventJSONRequestBody, reqEditors ...RequestEditorFn) (*ProcessAirbaseMilestoneEventResponse, error) {
	rsp, err := c.ProcessAirbaseMilestoneEvent(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessAirbaseMilestoneEventResponse(rsp)
}

// ParseGetAccountsResponse parses an HTTP response from a GetAccountsWithResponse call
func ParseGetAccountsResponse(rsp *http.Response) (*GetAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageAccount
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePostAccountsResponse parses an HTTP response from a PostAccountsWithResponse call
func ParsePostAccountsResponse(rsp *http.Response) (*PostAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobStateOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetUploadJobStateResponse parses an HTTP response from a GetUploadJobStateWithResponse call
func ParseGetUploadJobStateResponse(rsp *http.Response) (*GetUploadJobStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUploadJobStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobStateOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetActivityLogsResponse parses an HTTP response from a GetActivityLogsWithResponse call
func ParseGetActivityLogsResponse(rsp *http.Response) (*GetActivityLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivityLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LimitOffsetPageActivityLog
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseActivityRecordsResponse parses an HTTP response from a ActivityRecordsWithResponse call
func ParseActivityRecordsResponse(rsp *http.Response) (*ActivityRecordsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivityRecordsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActivityRecordOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetActivityRecordsJobStateResponse parses an HTTP response from a GetActivityRecordsJobStateWithResponse call
func ParseGetActivityRecordsJobStateResponse(rsp *http.Response) (*GetActivityRecordsJobStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivityRecordsJobStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncTaskOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListAppsResponse parses an HTTP response from a ListAppsWithResponse call
func ParseListAppsResponse(rsp *http.Response) (*ListAppsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCreateAppResponse parses an HTTP response from a CreateAppWithResponse call
func ParseCreateAppResponse(rsp *http.Response) (*CreateAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetAppResponse parses an HTTP response from a GetAppWithResponse call
func ParseGetAppResponse(rsp *http.Response) (*GetAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest App
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCreateAccessRequestResponse parses an HTTP response from a CreateAccessRequestWithResponse call
func ParseCreateAccessRequestResponse(rsp *http.Response) (*CreateAccessRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAccessRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []AccessRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetAccessRequestsResponse parses an HTTP response from a GetAccessRequestsWithResponse call
func ParseGetAccessRequestsResponse(rsp *http.Response) (*GetAccessRequestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccessRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageAccessRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetAccessRequestResponse parses an HTTP response from a GetAccessRequestWithResponse call
func ParseGetAccessRequestResponse(rsp *http.Response) (*GetAccessRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccessRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccessRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetAppStoreAppsResponse parses an HTTP response from a GetAppStoreAppsWithResponse call
func ParseGetAppStoreAppsResponse(rsp *http.Response) (*GetAppStoreAppsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppStoreAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageAppStoreApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetAppStoreAppResponse parses an HTTP response from a GetAppStoreAppWithResponse call
func ParseGetAppStoreAppResponse(rsp *http.Response) (*GetAppStoreAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppStoreAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppStoreApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetAppStoreAppSettingsResponse parses an HTTP response from a GetAppStoreAppSettingsWithResponse call
func ParseGetAppStoreAppSettingsResponse(rsp *http.Response) (*GetAppStoreAppSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppStoreAppSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppStoreAppSettingsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUpdateAppStoreAppSettingsResponse parses an HTTP response from a UpdateAppStoreAppSettingsWithResponse call
func ParseUpdateAppStoreAppSettingsResponse(rsp *http.Response) (*UpdateAppStoreAppSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAppStoreAppSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppStoreAppSettingsOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetResponse parses an HTTP response from a GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetWithResponse call
func ParseGetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetResponse(rsp *http.Response) (*GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppstorePreApprovalRulesForAppAppstorePreApprovalRulesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagePreApprovalRuleOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCreatePreApprovalRuleAppstorePreApprovalRulesPostResponse parses an HTTP response from a CreatePreApprovalRuleAppstorePreApprovalRulesPostWithResponse call
func ParseCreatePreApprovalRuleAppstorePreApprovalRulesPostResponse(rsp *http.Response) (*CreatePreApprovalRuleAppstorePreApprovalRulesPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePreApprovalRuleAppstorePreApprovalRulesPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PreApprovalRuleOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGetResponse parses an HTTP response from a GetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGetWithResponse call
func ParseGetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGetResponse(rsp *http.Response) (*GetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppstorePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PreApprovalRuleOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchResponse parses an HTTP response from a UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchWithResponse call
func ParseUpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchResponse(rsp *http.Response) (*UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePreApprovalRuleAppstorePreApprovalRulesPreApprovalRuleIdPatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PreApprovalRuleOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetAppstorePermissionsForAppAppstoreRequestablePermissionsGetResponse parses an HTTP response from a GetAppstorePermissionsForAppAppstoreRequestablePermissionsGetWithResponse call
func ParseGetAppstorePermissionsForAppAppstoreRequestablePermissionsGetResponse(rsp *http.Response) (*GetAppstorePermissionsForAppAppstoreRequestablePermissionsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppstorePermissionsForAppAppstoreRequestablePermissionsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageRequestablePermissionOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostResponse parses an HTTP response from a CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostWithResponse call
func ParseCreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostResponse(rsp *http.Response) (*CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAppstoreRequestablePermissionAppstoreRequestablePermissionsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RequestablePermissionOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDeleteResponse parses an HTTP response from a DeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDeleteWithResponse call
func ParseDeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDeleteResponse(rsp *http.Response) (*DeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAppstorePermissionAppstoreRequestablePermissionsPermissionIdDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGetResponse parses an HTTP response from a GetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGetWithResponse call
func ParseGetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGetResponse(rsp *http.Response) (*GetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppstorePermissionAppstoreRequestablePermissionsPermissionIdGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestablePermissionOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchResponse parses an HTTP response from a UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchWithResponse call
func ParseUpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchResponse(rsp *http.Response) (*UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAppstorePermissionAppstoreRequestablePermissionsPermissionIdPatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestablePermissionOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseLumosArtResponse parses an HTTP response from a LumosArtWithResponse call
func ParseLumosArtResponse(rsp *http.Response) (*LumosArtResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LumosArtResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateFoundDocumentResponse parses an HTTP response from a CreateFoundDocumentWithResponse call
func ParseCreateFoundDocumentResponse(rsp *http.Response) (*CreateFoundDocumentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFoundDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetGroupsResponse parses an HTTP response from a GetGroupsWithResponse call
func ParseGetGroupsResponse(rsp *http.Response) (*GetGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetGroupResponse parses an HTTP response from a GetGroupWithResponse call
func ParseGetGroupResponse(rsp *http.Response) (*GetGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetGroupMembershipResponse parses an HTTP response from a GetGroupMembershipWithResponse call
func ParseGetGroupMembershipResponse(rsp *http.Response) (*GetGroupMembershipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupMembershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseLumosLivenessCheckResponse parses an HTTP response from a LumosLivenessCheckWithResponse call
func ParseLumosLivenessCheckResponse(rsp *http.Response) (*LumosLivenessCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LumosLivenessCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ParseGetInlineWebhooksInlineWebhooksGetResponse parses an HTTP response from a GetInlineWebhooksInlineWebhooksGetWithResponse call
func ParseGetInlineWebhooksInlineWebhooksGetResponse(rsp *http.Response) (*GetInlineWebhooksInlineWebhooksGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInlineWebhooksInlineWebhooksGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []InlineWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ParseCreateOrderResponse parses an HTTP response from a CreateOrderWithResponse call
func ParseCreateOrderResponse(rsp *http.Response) (*CreateOrderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCurrentUserResponse parses an HTTP response from a CurrentUserWithResponse call
func ParseCurrentUserResponse(rsp *http.Response) (*CurrentUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CurrentUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListVendorAgreementsResponse parses an HTTP response from a ListVendorAgreementsWithResponse call
func ParseListVendorAgreementsResponse(rsp *http.Response) (*ListVendorAgreementsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListVendorAgreementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageVendorAgreement
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseProcessAirbaseMilestoneEventResponse parses an HTTP response from a ProcessAirbaseMilestoneEventWithResponse call
func ParseProcessAirbaseMilestoneEventResponse(rsp *http.Response) (*ProcessAirbaseMilestoneEventResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessAirbaseMilestoneEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}
